<!DOCTYPE html>
<html lang="vi">

    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="./css/common.css">
        <title>ÂÖ•Âäõ - ÊñáÊ≥ïÁ∑¥Áøí</title>
        <style>
        :root {
            --input-focus-border: #80bdff;
            --highlight-bg: #fff8b9;
            --table-hover-bg: #f1f1f1;
            --passage-header-bg: #eaf2ff; /* Lighter blue for passage header */
            --single-header-bg: #e6fffa;  /* Lighter cyan for single question header */
        }

        .dark-mode {
            --input-focus-border: #5897fb;
            --highlight-bg: #4a420c;
            --table-hover-bg: #2c2c2c;
            --passage-header-bg: #2a3a4a; /* Dark blue for dark mode */
            --single-header-bg: #2a4a4a;  /* Dark cyan for dark mode */
        }

        textarea,
        [contenteditable="true"] {
            width: 100%;
            margin-top: 8px;
            border: 1px solid var(--border-color);
            background: var(--input-bg);
            color: var(--text-color);
            padding: 8px;
            border-radius: 4px;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th,
        td {
            border-bottom: 1px solid var(--border-color);
            padding: 12px 8px;
            vertical-align: top;
            text-align: left;
        }
        th {
            font-weight: bold;
            background-color: var(--bg-color);
        }

        tr:hover {
            background-color: var(--table-hover-bg);
        }

        th.passage-header {
            background-color: var(--passage-header-bg);
            text-align: left;
        }
        th.single-header {
            background-color: var(--single-header-bg);
            text-align: left;
        }

        /* --- Th√™m style cho b·∫£ng ƒë∆∞·ª£c d√°n v√†o --- */
        [contenteditable] table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
            border: 1px solid var(--border-color);
        }
        [contenteditable] th,
        [contenteditable] td {
            border: 1px solid var(--border-color);
            padding: 8px;
            text-align: left;
        }
        [contenteditable] th {
            background-color: var(--bg-color);
            font-weight: bold;
        }


        .multi-select-highlight {
            background-color: #fff8b9;
            /* M√†u v√†ng ƒë·ªÉ highlight */
        }

        #multiSelectToggle.active {
            background-color: #a0d2ff;
            /* M√†u xanh khi ch·∫ø ƒë·ªô ƒë∆∞·ª£c b·∫≠t */
            border-color: #6b9ac4;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
            padding: 15px;
            opacity: 0;
            transition: opacity 0.25s ease-in-out;
            /* Th√™m z-index ƒë·ªÉ ƒë·∫£m b·∫£o modal lu√¥n ·ªü tr√™n c√πng */
            z-index: 1050;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 8px;
            /* Thay ƒë·ªïi ƒë·ªÉ responsive */
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            box-sizing: border-box;
            /* Th√™m flex ƒë·ªÉ c·ªë ƒë·ªãnh footer */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .modal-footer {
            padding: 10px 20px;
            border-top: 1px solid #eee;
            text-align: right;
            flex-shrink: 0;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            margin: 4px 0 10px 0;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        input[type="text"]:focus, input[type="number"]:focus, textarea:focus, [contenteditable="true"]:focus {
            border-color: var(--input-focus-border);
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        .favorite-star {
            cursor: pointer;
            font-size: 1.5em;
            color: #ccc;
            transition: color 0.2s, transform 0.2s;
            user-select: none; /* NgƒÉn ch·ªçn text khi click */
        }

        .favorite-star.favorited {
            color: #ffc107; /* Gold color */
            transform: scale(1.1);
        }

        .modal.show {
            display: flex;
            opacity: 1;
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            /* Make radio buttons stack on small screens */
            #add-question-area > div:first-child label {
                display: block;
                margin-left: 0 !important;
                margin-bottom: 10px;
            }
            .modal-content {
                width: 95vw;
                max-width: 95vw;
            }
            #button-group {
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-start;
            }
            #button-group button {
                margin: 5px;
            }
        }

        /* --- N√∫t L√™n ƒë·∫ßu trang --- */
        #scrollTopBtn {
            display: none; /* ·∫®n theo m·∫∑c ƒë·ªãnh, JS s·∫Ω ƒëi·ªÅu khi·ªÉn */
            position: fixed;
            bottom: 20px;
            right: 30px;
            z-index: 99;
            border: none;
            outline: none;
            background-color: var(--primary-bg);
            color: var(--primary-text); /* S·ª≠ d·ª•ng bi·∫øn m√†u ƒë·ªÉ t∆∞∆°ng th√≠ch theme */
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            box-shadow: var(--shadow);
            transition: background-color 0.2s, opacity 0.2s, transform 0.2s;
            /* Th√™m flex ƒë·ªÉ cƒÉn gi·ªØa icon SVG */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #scrollTopBtn:hover {
            background-color: var(--primary-hover); /* Th√™m hi·ªáu ·ª©ng hover */
            transform: translateY(-2px); /* Hi·ªáu ·ª©ng nh·∫•c l√™n m·ªôt ch√∫t */
        }
    </style>
    </head>

    <body class="preload">
        <!-- Placeholder for the header component -->
        <header class="app-header">
            <div class="header-content">
                <div id="breadcrumbs" class="breadcrumbs"></div>
                <nav id="common-nav" class="nav-menu-desktop"></nav>
                <div class="header-actions">
                    <button id="theme-toggle-desktop"
                        onclick="toggleTheme()">üåô</button>
                </div>
            </div>
        </header>
        <!-- C√°c n√∫t ƒëi·ªÅu khi·ªÉn v√† menu cho di ƒë·ªông -->
        <div class="mobile-controls">
            <button id="theme-toggle" onclick="toggleTheme()">üåô</button>
            <button id="hamburger-menu" onclick="toggleMobileMenu()">‚ò∞</button>
        </div>
        <div id="mobile-menu-overlay" onclick="toggleMobileMenu()">
            <nav id="nav-menu-mobile" class="nav-menu-mobile"></nav>
        </div>

        <div class="container">

            <h2>üìò Th√™m c√¢u h·ªèi m·ªõi</h2>

            <div id="add-question-area"
                style="border: 1px solid #ccc; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div>
                    <label class="custom-radio"><input type="radio"
                            name="questionType"
                            value="single"
                            onchange="toggleInputType(this.value)"
                            checked><span>C√¢u h·ªèi ƒë∆°n</span></label>
                    <label class="custom-radio"
                        style="margin-left: 15px;"><input type="radio"
                            name="questionType" value="passage"
                            onchange="toggleInputType(this.value)"><span>B√†i ƒë·ªçc
                            (nhi·ªÅu c√¢u
                            h·ªèi)</span></label>
                </div>
                <div style="margin-top: 15px;">
                    <label for="questionTag"><b>Tag (B·ªô ƒë·ªÅ):</b> (v√≠ d·ª•: JLPT
                        T7/2017)</label>
                    <input type="text" id="questionTag"
                        placeholder="√Åp d·ª•ng cho c√°c c√¢u h·ªèi s·∫Øp th√™m..."
                        style="width: 100%;">
                </div>

                <!-- Form cho c√¢u h·ªèi ƒë∆°n -->
                <div id="single-question-form" style="margin-top: 15px;">
                    <div id="toolbarMulti" style="margin-bottom: 5px">
                        <button id="multiSelectToggle"
                            title="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô ch·ªçn nhi·ªÅu ƒë·ªÉ ƒë·ªãnh d·∫°ng vƒÉn b·∫£n"
                            onclick="toggleMultiSelectMode(this)">‚ú®
                            Ch·ªçn nhi·ªÅu</button>
                        <button onclick="formatMulti('bold')"><b>B</b></button>
                        <button
                            onclick="formatMulti('underline')"><u>U</u></button>
                        <button
                            onclick="formatMulti('strikeThrough')"><s>S</s></button>
                        <button onclick="clearFormatMulti()"
                            title="X√≥a ƒë·ªãnh d·∫°ng ƒë√£ ch·ªçn">üßπ Clear</button>
                    </div>
                    <div id="quick" contenteditable="true"
                        placeholder="D√°n nhi·ªÅu c√¢u h·ªèi ƒë∆°n c√≥ Ê≠£Ëß£ / ‰∏çÊ≠£Ëß£..."
                        style="min-height: 200px; white-space: pre-wrap"></div>
                    <button onclick="quickParse(this)" class="btn-primary"
                        title="Ph√¢n t√≠ch v√† xem tr∆∞·ªõc c√°c c√¢u h·ªèi ƒë∆°n t·ª´ n·ªôi dung ƒë√£ d√°n">‚öôÔ∏è
                        Ph√¢n
                        t√≠ch & L∆∞u c√¢u h·ªèi
                        ƒë∆°n</button>
                    <button type="button" onclick="clearSingleInput()">üóëÔ∏è X√≥a
                        n·ªôi
                        dung</button>
                </div>

                <!-- Form cho b√†i ƒë·ªçc -->
                <div id="passage-form" style="display: none; margin-top: 15px;">
                    <label for="passage-text"><b>N·ªôi dung b√†i ƒë·ªçc:</b></label>
                    <div id="passage-text" contenteditable="true"
                        placeholder="D√°n n·ªôi dung b√†i ƒë·ªçc v√†o ƒë√¢y..."
                        style="min-height: 150px; white-space: pre-wrap"></div>
                    <label for="passage-sub-questions"><b>C√°c c√¢u h·ªèi cho b√†i
                            ƒë·ªçc:</b></label>
                    <!-- Th√™m thanh c√¥ng c·ª• ƒë·ªãnh d·∫°ng cho c√¢u h·ªèi c·ªßa b√†i ƒë·ªçc -->
                    <div id="toolbarPassage" style="margin-bottom: 5px">
                        <button id="multiSelectTogglePassage"
                            title="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô ch·ªçn nhi·ªÅu ƒë·ªÉ ƒë·ªãnh d·∫°ng vƒÉn b·∫£n"
                            onclick="toggleMultiSelectMode(this, 'passage-sub-questions')">‚ú®
                            Ch·ªçn nhi·ªÅu</button>
                        <button
                            onclick="formatMulti('bold', 'passage-sub-questions')"><b>B</b></button>
                        <button
                            onclick="formatMulti('underline', 'passage-sub-questions')"><u>U</u></button>
                        <button
                            onclick="formatMulti('strikeThrough', 'passage-sub-questions')"><s>S</s></button>
                        <button title="X√≥a ƒë·ªãnh d·∫°ng ƒë√£ ch·ªçn"
                            onclick="clearFormatMulti('passage-sub-questions')">üßπ
                            Clear</button>
                    </div>
                    <div id="passage-sub-questions" contenteditable="true"
                        placeholder="D√°n c√°c c√¢u h·ªèi con (1. 2. ...) v√†o ƒë√¢y..."
                        style="min-height: 150px; white-space: pre-wrap"></div>
                    <br>
                    <button onclick="(async () => await savePassage())()" class="btn-primary"
                        title="Ph√¢n t√≠ch v√† xem tr∆∞·ªõc b√†i ƒë·ªçc t·ª´ n·ªôi dung ƒë√£ d√°n">‚öôÔ∏è
                        L∆∞u
                        b√†i ƒë·ªçc & c√°c c√¢u
                        h·ªèi</button>
                    <button type="button" onclick="clearPassageInput()">üóëÔ∏è X√≥a
                        n·ªôi
                        dung</button>
                </div>
            </div>

            <h2 style="margin-top: 40px;">üìö Danh s√°ch b√†i ƒë·ªçc</h2>
             <div>
                <div style="overflow-x: auto; margin-top: 15px;">
                    <table id="passage-questions-tbl">
                        <thead>
                            <tr>
                                <th style="width: 30px;">
                                    <label class="custom-checkbox"
                                        title="Ch·ªçn t·∫•t c·∫£ b√†i ƒë·ªçc"><input type="checkbox"
                                            id="select-all-passages"><span></span></label>
                                </th>
                                <th style="width: 30px;">‚≠ê</th>
                                <th>#</th>
                                <th>N·ªôi dung b√†i ƒë·ªçc</th>
                                <th>Tag</th>
                                <th>S·ªë c√¢u con</th>
                                <th>Th·ªëng k√™ (ƒê√∫ng/L·∫ßn l√†m)</th>
                                <th>Thao t√°c</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <h2>üìù Danh s√°ch c√¢u h·ªèi ƒë∆°n</h2>
            <div>
                <div class="input-with-clear-container" style="margin-bottom: 10px;">
                    <input type="text" id="searchInput" oninput="render()"
                    placeholder="T√¨m ki·∫øm trong c√¢u h·ªèi, ƒë√°p √°n, tag..."
                    style="width: 100%; padding: 8px; box-sizing: border-box;">
                <span id="clear-search-btn" class="clear-btn"
                    title="X√≥a">&times;</span>
            </div>
            <div id="button-group">
                <label class="custom-checkbox"
                    style="display: inline-flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="show-favorites-only"
                        onchange="render()"><span>Ch·ªâ hi·ªÉn th·ªã c√¢u g·∫Øn sao</span>
                </label>
                <span
                    style="border-left: 1px solid var(--border-color); margin: 0 10px;"></span>
                <button onclick="openBulkDeleteModal()" id="bulk-delete-btn"
                    class="btn-danger" style="display: none;">üóëÔ∏è X√≥a c√°c c√¢u ƒë√£
                    ch·ªçn</button>
                <button onclick="exportJSON()"
                    title="Xu·∫•t to√†n b·ªô c√¢u h·ªèi ra file JSON">üíæ Xu·∫•t d·ªØ
                    li·ªáu</button>
                <button onclick="clearAll()" class="btn-danger">üóë X√≥a to√†n
                    b·ªô</button>
            </div>
            <div style="overflow-x: auto; margin-top: 15px;">
                <table id="single-questions-tbl">
                    <thead>
                        <tr>
                            <th style="width: 30px;">
                                <label class="custom-checkbox"
                                    title="Ch·ªçn t·∫•t c·∫£"><input type="checkbox"
                                        id="select-all-questions"><span></span></label>
                            </th>
                            <th style="width: 30px;">‚≠ê</th>
                            <th>#</th>
                            <th>C√¢u h·ªèi</th>
                            <th>Tag</th>
                            <th>Ê≠£Ëß£</th>
                            <th>Th·ªëng k√™ (ƒê√∫ng/L·∫ßn l√†m)</th>
                            <th>Thao t√°c</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <!-- Modal x√°c nh·∫≠n x√≥a h√†ng lo·∫°t -->
            <div class="modal" id="bulkDeleteConfirmModal">
                <div class="modal-content">
                    <div class="modal-body">
                        <h3>‚ö†Ô∏è X√°c nh·∫≠n x√≥a</h3>
                        <p>B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a vƒ©nh vi·ªÖn <b
                                id="bulk-delete-count"></b> c√¢u h·ªèi ƒë√£ ch·ªçn
                            kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.</p>
                        <div id="bulk-delete-list"
                            style="max-height: 200px; overflow-y: auto; background: var(--bg-color); border: 1px solid var(--border-color); padding: 10px; border-radius: 4px; margin-top: 10px;">
                            <!-- Danh s√°ch c√¢u h·ªèi s·∫Ω b·ªã x√≥a -->
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button onclick="confirmBulkDelete(this)"
                            class="btn-danger">üóëÔ∏è X√°c nh·∫≠n x√≥a</button>
                        <button onclick="closeBulkDeleteModal()">‚úñ H·ªßy</button>
                    </div>
                </div>
            </div>

            <div class="modal" id="editModal">
                <div class="modal-content">
                    <div class="modal-body">
                        <h3>‚úèÔ∏è S·ª≠a c√¢u h·ªèi</h3>
                        <label>C√¢u h·ªèi:</label>
                        <div id="editQ" contenteditable="true"
                            style="min-height: 80px; white-space: pre-wrap;">
                        </div>

                        <div style="margin-top: 6px">
                            <button type="button"
                                onclick="toggleMultiSelectMode(this, 'editQ')">‚ú®
                                Ch·ªçn nhi·ªÅu</button>
                            <button type="button"
                                onclick="formatEdit('bold')"><b>B</b></button>
                            <button type="button"
                                onclick="formatEdit('underline')">
                                <u>U</u>
                            </button>
                            <button type="button"
                                onclick="formatEdit('strikeThrough')">
                                <s>S</s>
                            </button>
                            <button type="button" onclick="clearFormatEdit()">üßπ
                                Clear</button>
                        </div>

                        <label>ƒê√°p √°n 1:</label><input type="text"
                            id="editC1" />
                        <label>ƒê√°p √°n 2:</label><input type="text"
                            id="editC2" />
                        <label>ƒê√°p √°n 3:</label><input type="text"
                            id="editC3" />
                        <label>ƒê√°p √°n 4:</label><input type="text"
                            id="editC4" />
                        <label>ƒê√∫ng (1-4):</label><input type="number"
                            id="editCorrect"
                            min="1" max="4" />
                        <label for="editTag">Tag (B·ªô ƒë·ªÅ):</label><input
                            type="text"
                            id="editTag" />
                        <label for="editExplanation">Gi·∫£i th√≠ch (Tham
                            kh·∫£o):</label>
                        <div id="toolbarExplanation" style="margin-top: 6px">
                            <button type="button"
                                onclick="formatEdit('bold', 'editExplanation')"><b>B</b></button>
                            <button type="button"
                                onclick="formatEdit('underline', 'editExplanation')"><u>U</u></button>
                            <button type="button"
                                onclick="formatEdit('strikeThrough', 'editExplanation')"><s>S</s></button>
                        </div>
                        <div id="editExplanation" contenteditable="true"
                            style="min-height: 80px; white-space: pre-wrap;">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button onclick="saveEdit()" class="btn-primary">üíæ
                            L∆∞u</button>
                        <button onclick="closeModal()">‚úñ ƒê√≥ng</button>
                    </div>
                </div>
            </div>

            <!-- Modal s·ª≠a B√ÄI ƒê·ªåC -->
            <div class="modal" id="passageEditModal">
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-body">
                        <h3>‚úèÔ∏è S·ª≠a b√†i ƒë·ªçc</h3>

                        <label for="passageEditText"><b>N·ªôi dung b√†i
                                ƒë·ªçc:</b></label>
                        <div id="passageEditText" contenteditable="true"
                            style="min-height: 150px; white-space: pre-wrap"></div>
                        <br>
                        <label for="passageEditTag"><b>Tag (B·ªô
                                ƒë·ªÅ):</b></label><input type="text"
                            id="passageEditTag" />
                        <br>

                        <label for="passageEditSubQuestions"><b>C√°c c√¢u h·ªèi cho
                                b√†i
                                ƒë·ªçc:</b></label>
                        <div id="toolbarPassageEdit" style="margin-bottom: 5px">
                            <button
                                onclick="toggleMultiSelectMode(this, 'passageEditSubQuestions')">‚ú®
                                Ch·ªçn nhi·ªÅu</button>
                            <button
                                onclick="formatMulti('bold', 'passageEditSubQuestions')"><b>B</b></button>
                            <button
                                onclick="formatMulti('underline', 'passageEditSubQuestions')"><u>U</u></button>
                            <button
                                onclick="formatMulti('strikeThrough', 'passageEditSubQuestions')"><s>S</s></button>
                            <button
                                onclick="clearFormatMulti('passageEditSubQuestions')">üßπ
                                Clear</button>
                        </div>
                        <div id="passageEditSubQuestions" contenteditable="true"
                            style="min-height: 200px; white-space: pre-wrap"></div>
                    </div>
                    <div class="modal-footer">
                        <button onclick="savePassageEdit()"
                            style="background-color: var(--primary-bg); color: var(--primary-text);">üíæ
                            L∆∞u thay ƒë·ªïi</button>
                        <button onclick="closePassageModal()">‚úñ ƒê√≥ng</button>
                    </div>
                </div>
            </div>
            <div class="modal" id="dupModal">
                <div class="modal-content">
                    <div class="modal-body">
                        <h3>‚ö†Ô∏è C√¢u h·ªèi tr√πng l·∫∑p</h3>
                        <p>Ch·ªçn nh·ªØng c√¢u b·∫°n mu·ªën <b>ghi ƒë√®</b>:</p>
                        <div id="dupList"
                            style="margin-top:8px; border:1px solid #ccc; padding:6px; background:#fafafa;"></div>
                    </div>
                    <div class="modal-footer">
                        <button onclick="confirmDup(this)" class="btn-primary">‚úÖ
                            X√°c nh·∫≠n</button>
                        <button onclick="closeDup()">‚úñ ƒê√≥ng</button>
                    </div>
                </div>
            </div>

            <!-- Modal xem tr∆∞·ªõc b√†i ƒë·ªçc -->
            <div class="modal" id="passagePreviewModal">
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-body">
                        <h3>üîç Xem tr∆∞·ªõc b√†i ƒë·ªçc & c√¢u h·ªèi</h3>
                        <h4>N·ªôi dung b√†i ƒë·ªçc:</h4>
                        <div id="previewPassageContent"
                            style="background: #f9f9f9; border: 1px solid #eee; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                        </div>

                        <h4 style="margin-top: 20px;">C√°c c√¢u h·ªèi ƒë√£ ph√¢n
                            t√≠ch:</h4>
                        <div id="previewSubQuestionsList"></div>
                    </div>
                    <div class="modal-footer">
                        <button onclick="confirmSavePassage(this)"
                            class="btn-primary">‚úÖ X√°c nh·∫≠n & L∆∞u</button>
                        <button onclick="closePassagePreviewModal()">‚úñ
                            H·ªßy</button>
                    </div>
                </div>
            </div>

            <!-- Modal xem tr∆∞·ªõc c√¢u h·ªèi ƒë∆°n -->
            <div class="modal" id="parsePreviewModal"
                style="align-items: flex-start; padding-top: 5vh;">
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-body">
                        <h3>üîç Xem tr∆∞·ªõc c√°c c√¢u h·ªèi ƒë√£ ph√¢n t√≠ch</h3>
                        <p>Ch·ªçn nh·ªØng c√¢u h·ªèi b·∫°n mu·ªën l∆∞u. B·ªè ch·ªçn nh·ªØng c√¢u
                            ph√¢n
                            t√≠ch sai
                            ho·∫∑c kh√¥ng mu·ªën th√™m. B·∫°n c√≥ th·ªÉ <b>s·ª≠a tr·ª±c
                                ti·∫øp</b>
                            c√°c c√¢u h·ªèi tr∆∞·ªõc khi l∆∞u.</p>
                        <div id="parsePreviewList"
                            style="margin-top: 15px;"></div>
                    </div>
                    <div class="modal-footer">
                        <button onclick="confirmQuickParse(this)"
                            class="btn-primary">‚úÖ X√°c nh·∫≠n & L∆∞u c√°c c√¢u ƒë√£
                            ch·ªçn</button>
                        <button onclick="closeParsePreviewModal()">‚úñ
                            H·ªßy</button>
                    </div>
                </div>
            </div>

        </div> <!-- End .container -->

        <!-- N√∫t L√™n ƒë·∫ßu trang -->
        <button onclick="scrollToTop()" id="scrollTopBtn" title="L√™n ƒë·∫ßu trang">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>
        </button>

        <script
            src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
        <script
            src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
        <!-- T·∫£i c·∫•u h√¨nh v√† kh·ªüi t·∫°o Firebase t·ª´ file ri√™ng -->
        <script src="./js/firebase-init.js"></script>
        <script src="./js/common.js"></script>

        <script>
        let questions = []; // D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ Firebase
        let editIndex = -1;
        let tempParsedQuestions = []; // L∆∞u c√°c c√¢u h·ªèi ƒë√£ ph√¢n t√≠ch t·∫°m th·ªùi
        let isMultiSelectMode = false;

        // T·∫£i d·ªØ li·ªáu t·ª´ Firestore
        async function loadQuestions() {
            try {
                // T·∫£i c√¢u h·ªèi, s·∫Øp x·∫øp theo timestamp m·ªõi nh·∫•t l√™n ƒë·∫ßu
                const snapshot = await questionsCollection.orderBy("timestamp", "desc").get();
                questions = snapshot.docs.map(doc => ({
                    id: doc.id, // L∆∞u ID c·ªßa document ƒë·ªÉ thao t√°c s·ª≠a/x√≥a
                    ...doc.data()
                }));
                render();
            } catch (error) {
                console.error("L·ªói khi t·∫£i c√¢u h·ªèi:", error);
                alert("L·ªói khi t·∫£i c√¢u h·ªèi. Ki·ªÉm tra console.");
            }
        }

        function render() {
            const searchTerm = document.getElementById("searchInput")?.value.toLowerCase() || "";
            const showFavoritesOnly = document.getElementById("show-favorites-only")?.checked || false;
            const singleTbody = document.querySelector("#single-questions-tbl tbody");
            const passageTbody = document.querySelector("#passage-questions-tbl tbody");
            singleTbody.innerHTML = "";
            passageTbody.innerHTML = "";

            let filteredQuestions = questions;

            if (showFavoritesOnly) {
                filteredQuestions = filteredQuestions.filter(q => q.isFavorite);
            }

            filteredQuestions = filteredQuestions.filter(q => {
                // T√¨m ki·∫øm tr√™n n·ªôi dung text c·ªßa c√¢u h·ªèi, kh√¥ng bao g·ªìm HTML
                if (!q) return false;
                let contentToSearch = "";
                if (q.type === 'passage') {
                    // ƒê·ªëi v·ªõi b√†i ƒë·ªçc, t√¨m ki·∫øm trong n·ªôi dung b√†i ƒë·ªçc, c√¢u h·ªèi con, ƒë√°p √°n con, gi·∫£i th√≠ch con
                    contentToSearch = q.passage || "";
                    if (q.sub_questions) {
                        q.sub_questions.forEach(subQ => {
                            contentToSearch += " " + (subQ.question || "");
                            contentToSearch += " " + (subQ.choices ? subQ.choices.join(' ') : "");
                            contentToSearch += " " + (subQ.explanation || "");
                        });
                    }
                } else {
                    // ƒê·ªëi v·ªõi c√¢u h·ªèi ƒë∆°n, t√¨m ki·∫øm trong n·ªôi dung c√¢u h·ªèi, ƒë√°p √°n, gi·∫£i th√≠ch
                    contentToSearch = q.question || "";
                    contentToSearch += " " + (q.choices ? q.choices.join(' ') : "");
                    contentToSearch += " " + (q.tag || "");
                    contentToSearch += " " + (q.explanation || "");
                }
                return contentToSearch.replace(/<[^>]+>/g, "").toLowerCase().includes(searchTerm);
            });

            // T√°ch th√†nh 2 nh√≥m v√† render v√†o c√°c b·∫£ng t∆∞∆°ng ·ª©ng
            const passages = filteredQuestions.filter(q => q.type === 'passage');
            const singles = filteredQuestions.filter(q => q.type !== 'passage');

            passages.forEach((q, index) => renderRow(q, index, passageTbody));
            singles.forEach((q, index) => renderRow(q, index, singleTbody));

            // H√†m ph·ª• ƒë·ªÉ render m·ªôt d√≤ng
            function renderRow(q, displayIndex, targetTbody) {
                // T√¨m index g·ªëc c·ªßa c√¢u h·ªèi trong m·∫£ng `questions` ƒë·ªÉ c√°c h√†m s·ª≠a/x√≥a ho·∫°t ƒë·ªông ƒë√∫ng
                const originalIndex = questions.findIndex(originalQ => originalQ.id === q.id);
                if (originalIndex === -1) return; // B·ªè qua n·∫øu kh√¥ng t√¨m th·∫•y

                const tr = document.createElement("tr");
                const starClass = q.isFavorite ? 'favorited' : '';
                const starIcon = q.isFavorite ? '‚≠ê' : '‚òÜ';
                if (q.type === 'passage' && q.sub_questions) {
                    const totalAttemptedSubQuestions = (q.attempts || 0) * (q.totalSubQuestions || q.sub_questions.length);
                    tr.innerHTML = `
                        <td>
                            <label class="custom-checkbox"><input type="checkbox" class="question-checkbox" value="${q.id}"><span></span></label>
                        </td>
                        <td><span class="favorite-star ${starClass}" onclick="toggleFavorite(event, ${originalIndex})">${starIcon}</span></td>
                        <td>${displayIndex + 1}</td>
                        <td>
                            <div style="font-weight: bold; color: #005a9e;">[B√ÄI ƒê·ªåC]</div>
                            <div>${q.passage.substring(0, 150)}... (${q.sub_questions.length} c√¢u h·ªèi)</div>
                        </td>
                        <td>${q.tag || ""}</td>
                        <td style="text-align: center;">${q.sub_questions.length}</td>
                        <td style="text-align: center;">${q.correctAttempts || 0}/${totalAttemptedSubQuestions}</td>
                        <td><button onclick="openEdit(${originalIndex})">S·ª≠a</button><button onclick="del(${originalIndex})">X√≥a</button></td>`;
                } else { // M·∫∑c ƒë·ªãnh l√† c√¢u h·ªèi ƒë∆°n
                    tr.innerHTML = `
                        <td>
                            <label class="custom-checkbox"><input type="checkbox" class="question-checkbox" value="${q.id}"><span></span></label>
                        </td>
                        <td><span class="favorite-star ${starClass}" onclick="toggleFavorite(event, ${originalIndex})">${starIcon}</span></td>
                        <td>${displayIndex + 1}</td>
                        <td>${q.question}</td>
                        <td>${q.tag || ""}</td>
                        <td>${q.choices[q.correct] || ""}</td>
                        <td style="text-align: center;">${q.correctAttempts || 0}/${q.attempts || 0}</td>
                        <td><button onclick="openEdit(${originalIndex})">S·ª≠a</button><button onclick="del(${originalIndex})">X√≥a</button></td>`;
                }
                targetTbody.appendChild(tr);
            }

            // G·∫Øn l·∫°i s·ª± ki·ªán cho c√°c checkbox sau khi render
            attachCheckboxListeners();
        }

        async function toggleFavorite(event, index) {
            event.stopPropagation(); // NgƒÉn c√°c s·ª± ki·ªán click kh√°c
            const question = questions[index];
            if (!question || !question.id) return;

            const newFavoriteStatus = !question.isFavorite;

            // C·∫≠p nh·∫≠t giao di·ªán ngay l·∫≠p t·ª©c
            question.isFavorite = newFavoriteStatus;
            const starSpan = event.target;
            starSpan.textContent = newFavoriteStatus ? '‚≠ê' : '‚òÜ';
            starSpan.classList.toggle('favorited', newFavoriteStatus);

            try {
                await questionsCollection.doc(question.id).update({
                    isFavorite: newFavoriteStatus
                });
            } catch (error) {
                console.error("L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i y√™u th√≠ch:", error);
                alert("C√≥ l·ªói x·∫£y ra, vui l√≤ng th·ª≠ l·∫°i.");
                // Rollback a giao di·ªán n·∫øu l·ªói
                question.isFavorite = !newFavoriteStatus;
                starSpan.textContent = !newFavoriteStatus ? '‚≠ê' : '‚òÜ';
                starSpan.classList.toggle('favorited', !newFavoriteStatus);
            }
        }

        let tempDup = []; // l∆∞u danh s√°ch tr√πng t·∫°m
        let tempPassageData = null; // D·ªØ li·ªáu b√†i ƒë·ªçc t·∫°m th·ªùi cho vi·ªác xem tr∆∞·ªõc

        // üîπ H√†m t√°i s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n t√≠ch c√¢u h·ªèi t·ª´ HTML
        function parseQuestionsFromHTML(html) {
            const questions = [];
            if (!html) return questions;

            // 1. Chu·∫©n h√≥a v√† t√°ch th√†nh c√°c kh·ªëi c√¢u h·ªèi
            // Thay th·∫ø <div> b·∫±ng \n ƒë·ªÉ x·ª≠ l√Ω nh∆∞ c√°c d√≤ng ri√™ng bi·ªát
            // T√°ch c√°c kh·ªëi d·ª±a tr√™n c√°c ƒë·ªãnh d·∫°ng: "1.", "50", "„Äê50„Äë"
            const normalizedHtml = html.replace(/<div>/g, '\n').split(/\n?\s*<br[^>]*>\s*\n?|\n/).join('\n');
            const questionBlocks = normalizedHtml.split(/\n\s*(?=(?:„Äê\d+\s*„Äë)|(?:\d+\.\s*)|(?:^\d+\s*$(?!\))))/m).filter(block => block.trim() !== '');

            questionBlocks.forEach((block) => {
                const lines = block.trim().split('\n'); // Gi·ªØ l·∫°i c√°c d√≤ng tr·ªëng ƒë·ªÉ x·ª≠ l√Ω <br>
                if (lines.length === 0) return;

                const questionLines = [];
                let firstChoiceIndex = -1;

                // 2. T√°ch ph·∫ßn c√¢u h·ªèi v√† ph·∫ßn l·ª±a ch·ªçn
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    // D·∫•u hi·ªáu b·∫Øt ƒë·∫ßu c·ªßa ph·∫ßn l·ª±a ch·ªçn/ƒë√°p √°n
                    const isChoiceStart = /^(?:(Ê≠£Ëß£|‰∏çÊ≠£Ëß£)[:Ôºö]?\s*)?\d+\)/.test(line) || /^Ê≠£Ëß£[:Ôºö]?\s*\d+/.test(line) || /^‰∏çÊ≠£Ëß£[:Ôºö]?\s*\d+/.test(line);

                    if (isChoiceStart && firstChoiceIndex === -1) {
                        firstChoiceIndex = i;
                        break;
                    }
                    questionLines.push(lines[i]); // Gi·ªØ l·∫°i line g·ªëc c√≥ th·ªÉ ch·ª©a HTML
                }

                // X·ª≠ l√Ω ph·∫ßn c√¢u h·ªèi
                let questionHTML = questionLines.join('<br>').replace(/^\s*<br>|<br>\s*$/g, '').trim(); // N·ªëi c√°c d√≤ng c√¢u h·ªèi
                const fillInTheBlankMatch = questionHTML.match(/^(?:„Äê(\d+)„Äë|(\d+))$/);

                if (fillInTheBlankMatch) {
                    const number = fillInTheBlankMatch[1] || fillInTheBlankMatch[2];
                    questionHTML = `(ƒêi·ªÅn v√†o ch·ªó tr·ªëng ${number})`;
                } else {
                    questionHTML = questionHTML.replace(/^\d+\.\s*/, ''); // X√≥a s·ªë th·ª© t·ª± ·ªü ƒë·∫ßu cho c√¢u h·ªèi th∆∞·ªùng
                }

                const otherLines = firstChoiceIndex !== -1 ? lines.slice(firstChoiceIndex) : [];

                const choices = [];
                let correct = -1;
                let explanation = "";

                // 3. Ph√¢n t√≠ch c√°c l·ª±a ch·ªçn, ƒë√°p √°n v√† gi·∫£i th√≠ch t·ª´ c√°c d√≤ng c√≤n l·∫°i (ƒë√£ s·ª≠a ƒë·ªÉ h·ªó tr·ª£ gi·∫£i th√≠ch nhi·ªÅu d√≤ng)
                let isParsingExplanation = false;
                for (const line of otherLines) {
                    const textLine = line.replace(/<[^>]+>/g, "").trim(); // Lo·∫°i b·ªè tag HTML ƒë·ªÉ ph√¢n t√≠ch

                    if (isParsingExplanation) {
                        explanation += "\n" + line.trim(); // Gi·ªØ l·∫°i HTML n·∫øu c√≥
                        continue;
                    }

                    // Regex m·∫°nh m·∫Ω ƒë·ªÉ ph√¢n t√≠ch d√≤ng l·ª±a ch·ªçn
                    const choiceMatch = textLine.match(/^(?:(Ê≠£Ëß£|‰∏çÊ≠£Ëß£)[:Ôºö]?\s*)?(\d+)\)\s*(.*)/);
                    if (choiceMatch) {
                        const keyword = choiceMatch[1];
                        const index = parseInt(choiceMatch[2]) - 1;
                        const choiceText = choiceMatch[3].trim();
                        if (index >= 0) {
                            choices[index] = choiceText;
                        }
                        if (keyword === 'Ê≠£Ëß£' && correct === -1) {
                            correct = index;
                        }
                        continue;
                    }

                    // T√¨m ƒë√°p √°n ƒë√∫ng t·ª´ d√≤ng ri√™ng (v√≠ d·ª•: Ê≠£Ëß£: 3)
                    const correctLineMatch = textLine.match(/^Ê≠£Ëß£[:Ôºö]?\s*(\d+)/);
                    if (correctLineMatch && correct === -1) {
                        correct = parseInt(correctLineMatch[1]) - 1;
                        continue;
                    }

                    // T√¨m d√≤ng gi·∫£i th√≠ch
                    const explanationMatch = textLine.match(/^(?:Tham kh·∫£o|Gi·∫£i th√≠ch)[:Ôºö]\s*(.*)/i);
                    if (explanationMatch) {
                        explanation = explanationMatch[1].trim(); // L·∫•y ph·∫ßn ƒë·∫ßu ti√™n c·ªßa gi·∫£i th√≠ch
                        isParsingExplanation = true; // B·∫Øt ƒë·∫ßu ch·∫ø ƒë·ªô ph√¢n t√≠ch gi·∫£i th√≠ch
                        continue;
                    }
                }
                explanation = explanation.trim(); // X√≥a kho·∫£ng tr·∫Øng th·ª´a ·ªü cu·ªëi

                if (choices.length > 0 && correct !== -1) {
                    questions.push({ question: questionHTML, choices, correct, explanation });
                }
            });

            return questions;
        }

        function populateAndShowParsePreviewModal(parsedQuestions) {
            tempParsedQuestions = parsedQuestions;
            const previewList = document.getElementById('parsePreviewList');
            previewList.innerHTML = ""; // X√≥a n·ªôi dung c≈©

            parsedQuestions.forEach((q, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.id = `preview-item-${index}`;
                itemDiv.style = "border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px; background: #f9f9f9;";
                itemDiv.innerHTML = getParsedQuestionHTML(q, index);
                previewList.appendChild(itemDiv);
            });

            document.getElementById('parsePreviewModal').classList.add('show');
        }

        function getParsedQuestionHTML(q, index, isEditing = false) {
            if (isEditing) {
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: bold;"><input type="checkbox" class="parse-preview-checkbox" data-index="${index}" checked> C√¢u h·ªèi ${index + 1}</label>
                        <button onclick="saveParsedQuestionEdit(${index})">üíæ L∆∞u</button>
                    </div>
                    <div id="toolbar-preview-edit-${index}" style="margin-bottom: 5px; border: 1px solid #eee; padding: 3px; border-radius: 4px;">
                        <button onclick="toggleMultiSelectMode(this, 'edit-preview-q-${index}')" title="Ch·ªçn nhi·ªÅu">‚ú®</button>
                        <button onclick="formatMulti('bold', 'edit-preview-q-${index}')"><b>B</b></button>
                        <button onclick="formatMulti('underline', 'edit-preview-q-${index}')"><u>U</u></button>
                        <button onclick="formatMulti('strikeThrough', 'edit-preview-q-${index}')"><s>S</s></button>
                        <button onclick="clearFormatMulti('edit-preview-q-${index}')" title="X√≥a ƒë·ªãnh d·∫°ng">üßπ</button>
                    </div>
                    <div contenteditable="true" id="edit-preview-q-${index}" style="border: 1px dashed #ccc; padding: 5px; margin-bottom: 5px; background: white;">${q.question}</div>
                    ${[0, 1, 2, 3].map(cIndex => `
                        <div style="display: flex; align-items: center; margin-bottom: 3px;">
                            <span style="margin-right: 5px;">${cIndex + 1})</span>
                            <input type="text" id="edit-preview-c-${index}-${cIndex}" value="${q.choices[cIndex] || ''}" style="flex-grow: 1; padding: 3px;">
                        </div>
                    `).join('')}
                    <div style="display: flex; align-items: center; margin-top: 5px;">
                        <label for="edit-preview-correct-${index}" style="margin-right: 5px;">ƒê√°p √°n ƒë√∫ng (1-4):</label>
                        <input type="number" id="edit-preview-correct-${index}" value="${q.correct + 1}" min="1" max="4" style="width: 60px;">
                    </div>
                    <div style="display: flex; align-items: center; margin-top: 5px;">
                        <label for="edit-preview-tag-${index}" style="margin-right: 5px;">Tag:</label>
                        <input type="text" id="edit-preview-tag-${index}" value="${q.tag || ''}" style="flex-grow: 1; padding: 3px;">
                    </div>
                     <div style="margin-top: 5px;">
                        <label for="edit-preview-explanation-${index}" style="display:block; margin-bottom: 3px;">Gi·∫£i th√≠ch:</label>
                        <textarea id="edit-preview-explanation-${index}" style="width: 100%; font-size: 13px;" rows="2">${q.explanation || ''}</textarea>
                    </div>
                `;
            } else {
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: bold; flex-grow: 1;">
                            <input type="checkbox" class="parse-preview-checkbox" data-index="${index}" checked>
                            C√¢u h·ªèi ${index + 1}: ${q.question}
                        </label>
                        <button onclick="editParsedQuestion(${index})">‚úèÔ∏è S·ª≠a</button>
                    </div>
                    <ul>
                        ${q.choices.map((choice, cIndex) => `
                            <li style="${cIndex === q.correct ? 'font-weight: bold; color: green;' : ''}">
                                ${cIndex + 1}) ${choice}
                            </li>
                        `).join('')}
                    </ul>
                    ${q.tag ? `<div style="margin-top: 8px; font-style: italic; color: #555;"><b>Tag:</b> ${q.tag}</div>` : ''}
                    ${q.explanation ? `<div style="margin-top: 8px; padding: 5px; background-color: var(--explanation-bg); border-radius: 3px;"><b>Gi·∫£i th√≠ch:</b> ${q.explanation}</div>` : ''}
                `;
            }
        }

        function editParsedQuestion(index) {
            const q = tempParsedQuestions[index];
            const itemDiv = document.getElementById(`preview-item-${index}`);
            itemDiv.innerHTML = getParsedQuestionHTML(q, index, true);
            // G·∫Øn s·ª± ki·ªán ƒë·ªÉ ch·∫ø ƒë·ªô "Ch·ªçn nhi·ªÅu" ho·∫°t ƒë·ªông
            document.getElementById(`edit-preview-q-${index}`).addEventListener("mouseup", handleMouseUp);
        }

        function saveParsedQuestionEdit(index) {
            const q = tempParsedQuestions[index];
            // X√≥a c√°c highlight c·ªßa ch·∫ø ƒë·ªô "Ch·ªçn nhi·ªÅu" tr∆∞·ªõc khi l∆∞u
            removeHighlights(`edit-preview-q-${index}`);
            q.question = document.getElementById(`edit-preview-q-${index}`).innerHTML;
            q.choices = [0, 1, 2, 3].map(cIndex => document.getElementById(`edit-preview-c-${index}-${cIndex}`).value);
            q.correct = parseInt(document.getElementById(`edit-preview-correct-${index}`).value) - 1;
            q.tag = document.getElementById(`edit-preview-tag-${index}`).value;
            q.explanation = document.getElementById(`edit-preview-explanation-${index}`).value;

            const itemDiv = document.getElementById(`preview-item-${index}`);
            itemDiv.innerHTML = getParsedQuestionHTML(q, index, false);
            // ƒê·∫£m b·∫£o checkbox v·∫´n ƒë∆∞·ª£c ch·ªçn sau khi l∆∞u
            itemDiv.querySelector('.parse-preview-checkbox').checked = true;
        }

        function closeParsePreviewModal() {
            document.getElementById('parsePreviewModal').classList.remove('show');
            tempParsedQuestions = [];
            // K√≠ch ho·∫°t l·∫°i n√∫t "Ph√¢n t√≠ch" ban ƒë·∫ßu
            const quickParseBtn = document.querySelector('button[onclick^="quickParse"]');
            if (quickParseBtn) quickParseBtn.disabled = false;
        }

        // üîπ Ph√¢n t√≠ch nhi·ªÅu c√¢u h·ªèi (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Firestore)
        async function quickParse(button) {
            button.disabled = true; // V√¥ hi·ªáu h√≥a n√∫t ngay khi nh·∫•n
            const html = document.getElementById("quick").innerHTML.trim();
            if (!html) return alert("H√£y d√°n n·ªôi dung!");

            const tag = document.getElementById("questionTag").value.trim();
            const parsed = parseQuestionsFromHTML(html);
            const newQuestions = parsed.map(q => ({ ...q, type: 'single', tag: tag, attempts: 0, correctAttempts: 0 }));

            if (newQuestions.length === 0) {
                alert("‚ö†Ô∏è Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi n√†o!");
                button.disabled = false; // K√≠ch ho·∫°t l·∫°i n·∫øu kh√¥ng c√≥ g√¨ ƒë·ªÉ ph√¢n t√≠ch
                return;
            }

            // Hi·ªÉn th·ªã modal xem tr∆∞·ªõc thay v√¨ x·ª≠ l√Ω ngay
            populateAndShowParsePreviewModal(newQuestions);
        }

        async function confirmQuickParse(button) {
            const quickParseBtn = document.querySelector('button[onclick^="quickParse"]');
            button.disabled = true;
            button.textContent = 'ƒêang x·ª≠ l√Ω...';

            // ƒê·∫£m b·∫£o m·ªçi ch·ªânh s·ª≠a ƒëang m·ªü ƒë·ªÅu ƒë∆∞·ª£c l∆∞u l·∫°i
            document.querySelectorAll('[id^="edit-preview-q-"]').forEach(div => {
                div.closest('[id^="preview-item-"]').querySelector('button[onclick^="saveParsedQuestionEdit"]').click();
            });
            const selectedCheckboxes = document.querySelectorAll('.parse-preview-checkbox:checked');
            const selectedQuestions = Array.from(selectedCheckboxes).map(cb => {
                const index = parseInt(cb.getAttribute('data-index'));
                return tempParsedQuestions[index];
            });

            if (selectedQuestions.length === 0) {
                alert("B·∫°n ch∆∞a ch·ªçn c√¢u h·ªèi n√†o ƒë·ªÉ l∆∞u.");
                return;
            }
            const current = questions; // D√πng bi·∫øn questions ƒë√£ load t·ª´ Firestore
            const duplicates = [];
            const unique = [];

            for (const nq of selectedQuestions) {
                const dup = current.find(q =>
                    // Ch·ªâ so s√°nh n·∫øu q l√† c√¢u h·ªèi ƒë∆°n v√† c√≥ thu·ªôc t√≠nh 'question'
                    q.type !== 'passage' && q.question &&
                    q.question.replace(/<[^>]+>/g, "").trim() === nq.question.replace(/<[^>]+>/g, "").trim()
                );
                if (dup) {
                    duplicates.push({ ...nq, oldId: dup.id }); // L∆∞u c·∫£ ID c≈© ƒë·ªÉ ghi ƒë√®
                }
                else {
                    unique.push(nq);
                }
            }

        try {
            if (duplicates.length > 0) {
                tempDup = { duplicates, unique }; // Kh√¥ng c·∫ßn current v√¨ ƒë√£ c√≥ ID
                const list = document.getElementById("dupList");
                list.innerHTML = duplicates.map((q, i) => `
            <div style="margin-bottom:8px; background:#fff; padding:6px; border-radius:4px;">
              <label>
                <input type="checkbox" checked id="dup_${i}" />
                <span>${q.question}</span>
              </label>
            </div>
          `).join("");
                document.getElementById("dupModal").style.display = "flex";
            } else {
                // L∆∞u t·∫•t c·∫£ c√¢u h·ªèi m·ªõi v√†o Firestore
                await Promise.all(unique.map(q => questionsCollection.add({
                    ...q,
                    timestamp: serverTimestamp()
                })));
                alert(`‚úÖ ƒê√£ th√™m ${unique.length} c√¢u h·ªèi m·ªõi (gi·ªØ ƒë·ªãnh d·∫°ng HTML).`);
                closeParsePreviewModal();
                await loadQuestions(); // T·∫£i l·∫°i danh s√°ch
            }
        } catch (error) {
            console.error("L·ªói khi l∆∞u c√¢u h·ªèi duy nh·∫•t:", error);
            alert("ƒê√£ x·∫£y ra l·ªói khi l∆∞u c√¢u h·ªèi. Vui l√≤ng th·ª≠ l·∫°i.");
        } finally {
            // ƒê·∫£m b·∫£o c√°c n√∫t ƒë∆∞·ª£c k√≠ch ho·∫°t l·∫°i
            button.disabled = false;
            button.textContent = '‚úÖ X√°c nh·∫≠n & L∆∞u c√°c c√¢u ƒë√£ ch·ªçn';
            if (quickParseBtn) quickParseBtn.disabled = false;
        }
        }

        async function confirmDup(button) {
            const { duplicates, unique } = tempDup;

            button.disabled = true;
            button.textContent = 'ƒêang l∆∞u...';

            let updatedCount = 0;
            let addedCount = 0;

            // 1. X·ª≠ l√Ω c√°c c√¢u h·ªèi tr√πng l·∫∑p ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ ghi ƒë√® (UPDATE)
            const updatePromises = [];
            duplicates.forEach((q, i) => {
                const cb = document.getElementById(`dup_${i}`);
                if (cb && cb.checked) {
                    // Ghi ƒë√® c√¢u h·ªèi c≈© b·∫±ng d·ªØ li·ªáu m·ªõi, d√πng ID c≈© (q.oldId)
                    updatePromises.push(questionsCollection.doc(q.oldId).update({
                        question: q.question,
                        choices: q.choices,
                        correct: q.correct,
                        timestamp: serverTimestamp()
                        // Kh√¥ng reset attempts khi ghi ƒë√®, ch·ªâ c·∫≠p nh·∫≠t n·ªôi dung
                    }));
                    updatedCount++;
                } else {
                    // N·∫øu ng∆∞·ªùi d√πng kh√¥ng ch·ªçn ghi ƒë√®, h√£y th√™m n√≥ nh∆∞ m·ªôt c√¢u h·ªèi m·ªõi
                    unique.push(q);
                    updatedCount++;
                }
            });

            // 2. X·ª≠ l√Ω c√°c c√¢u h·ªèi ho√†n to√†n m·ªõi (ADD)
            const addPromises = unique.map(q => {
                addedCount++;
                return questionsCollection.add({
                    ...q,
                    timestamp: serverTimestamp()
                });
            });

            try {
                await Promise.all([...updatePromises, ...addPromises]);
                closeParsePreviewModal(); // ƒê√≥ng c·∫£ modal xem tr∆∞·ªõc
                await loadQuestions(); // T·∫£i l·∫°i danh s√°ch
                closeDup();
                alert(`‚úÖ ƒê√£ ho√†n th√†nh. ƒê√£ ghi ƒë√® ${updatedCount} c√¢u h·ªèi v√† th√™m ${addedCount} c√¢u h·ªèi m·ªõi.`);
            } catch (error) {
                console.error("L·ªói khi x√°c nh·∫≠n tr√πng l·∫∑p:", error);
                alert("ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i.");
            } finally { // ƒê·∫£m b·∫£o n√∫t ƒë∆∞·ª£c k√≠ch ho·∫°t l·∫°i
                button.disabled = false;
                button.textContent = '‚úÖ X√°c nh·∫≠n';
            }
        }

        // üîπ L∆∞u b√†i ƒë·ªçc
        async function savePassage() {
            const passageHTML = document.getElementById("passage-text").innerHTML.trim();
            const subQuestionsHTML = document.getElementById("passage-sub-questions").innerHTML.trim();

            if (!passageHTML) return alert("Vui l√≤ng nh·∫≠p n·ªôi dung b√†i ƒë·ªçc.");
            if (!subQuestionsHTML) return alert("Vui l√≤ng nh·∫≠p c√°c c√¢u h·ªèi cho b√†i ƒë·ªçc.");

            const sub_questions = parseQuestionsFromHTML(subQuestionsHTML);

            if (sub_questions.length === 0) {
                return alert("Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi con n√†o. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng.");
            }

            const tag = document.getElementById("questionTag").value.trim();
            // L∆∞u d·ªØ li·ªáu t·∫°m th·ªùi ƒë·ªÉ x√°c nh·∫≠n
            tempPassageData = {
                type: 'passage',
                passage: passageHTML,
                sub_questions: sub_questions,
                attempts: 0,
                tag: tag,
                correctAttempts: 0,
                totalSubQuestions: sub_questions.length, // Th√™m t·ªïng s·ªë c√¢u h·ªèi con
            };

            // Hi·ªÉn th·ªã modal xem tr∆∞·ªõc
            populateAndShowPreviewModal();
        }

        async function confirmSavePassage(button) {
            if (!tempPassageData) return;

            button.disabled = true;
            button.textContent = 'ƒêang l∆∞u...';

            const passageData = {
                ...tempPassageData,
                timestamp: serverTimestamp()
            };

            try {
                await questionsCollection.add(passageData);
                alert(`‚úÖ ƒê√£ l∆∞u b√†i ƒë·ªçc v·ªõi ${passageData.sub_questions.length} c√¢u h·ªèi th√†nh c√¥ng!`);
                document.getElementById("passage-text").innerHTML = "";
                document.getElementById("passage-sub-questions").innerHTML = "";
                closePassagePreviewModal();
                await loadQuestions();
            } catch (error) {
                console.error("L·ªói khi l∆∞u b√†i ƒë·ªçc:", error);
                alert("ƒê√£ x·∫£y ra l·ªói khi l∆∞u b√†i ƒë·ªçc. Vui l√≤ng ki·ªÉm tra console.");
            } finally {
                button.disabled = false;
                button.textContent = '‚úÖ X√°c nh·∫≠n & L∆∞u';
            }
        }

        function populateAndShowPreviewModal() {
            if (!tempPassageData) return;

            document.getElementById('previewPassageContent').innerHTML = tempPassageData.passage;

            const previewList = document.getElementById('previewSubQuestionsList');
            previewList.innerHTML = tempPassageData.sub_questions.map((sq, index) => `
                <div style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
                    <p><b>C√¢u h·ªèi ${index + 1}:</b> ${sq.question}</p>
                    <ul>
                        ${sq.choices.map((choice, cIndex) => `
                            <li style="${cIndex === sq.correct ? 'font-weight: bold; color: green;' : ''}">
                                ${cIndex + 1}) ${choice} ${cIndex === sq.correct ? '<b>(ƒê√°p √°n ƒë√∫ng)</b>' : ''}
                            </li>
                        `).join('')}
                    </ul>
                    ${sq.explanation ? `<div style="margin-top: 8px; padding: 5px; background-color: var(--explanation-bg); border-radius: 3px;"><b>Gi·∫£i th√≠ch:</b> ${sq.explanation}</div>` : ''}
                </div>
            `).join('');

            document.getElementById('passagePreviewModal').classList.add('show');
        }

        function closeDup() {
            document.getElementById("dupModal").style.display = "none";
            tempDup = [];
        }

        // üîπ Ch·ªânh s·ª≠a (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Firestore)
        function openEdit(i) {
            editIndex = i;
            const q = questions[i];

            if (q.type === 'passage') {
                document.getElementById("passageEditText").innerHTML = q.passage;
                document.getElementById("passageEditSubQuestions").innerHTML = formatSubQuestionsForEditing(q.sub_questions);
                document.getElementById("passageEditTag").value = q.tag || "";
                document.getElementById("passageEditModal").classList.add("show");
            } else {
                document.getElementById("editQ").innerHTML = q.question;
                document.getElementById("editC1").value = q.choices[0] || "";
                document.getElementById("editC2").value = q.choices[1] || "";
                document.getElementById("editC3").value = q.choices[2] || "";
                document.getElementById("editC4").value = q.choices[3] || "";
                document.getElementById("editCorrect").value = q.correct + 1;
                document.getElementById("editTag").value = q.tag || "";
                document.getElementById("editExplanation").innerHTML = q.explanation || "";
                document.getElementById("editModal").classList.add("show");
            }
        }

        // Helper ƒë·ªÉ format c√¢u h·ªèi con cho vi·ªác s·ª≠a
        function formatSubQuestionsForEditing(subQuestions) {
            if (!subQuestions) return "";
            return subQuestions.map((sq, index) => {
                const choicesStr = sq.choices.map((choice, cIndex) => `${cIndex + 1}) ${choice}`).join('\n');
                const correctStr = `Ê≠£Ëß£: ${sq.correct + 1}`;
                const explanationStr = sq.explanation ? `\nGi·∫£i th√≠ch: ${sq.explanation}` : '';
                return `${index + 1}. ${sq.question}\n${choicesStr}\n${correctStr}${explanationStr}`;
            }).join('\n\n'); // Th√™m d√≤ng tr·ªëng gi·ªØa c√°c c√¢u h·ªèi
        }

        // L∆∞u ch·ªânh s·ª≠a cho B√ÄI ƒê·ªåC
        async function savePassageEdit() {
            const q = questions[editIndex];
            const passageHTML = document.getElementById("passageEditText").innerHTML.trim();
            const subQuestionsHTML = document.getElementById("passageEditSubQuestions").innerHTML.trim();
            const tag = document.getElementById("passageEditTag").value.trim();

            if (!passageHTML || !subQuestionsHTML) {
                return alert("N·ªôi dung b√†i ƒë·ªçc v√† c√¢u h·ªèi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.");
            }

            const sub_questions = parseQuestionsFromHTML(subQuestionsHTML);
            if (sub_questions.length === 0) {
                return alert("Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi con n√†o. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë·ªãnh d·∫°ng.");
            }

            const updatedData = {
                passage: passageHTML,
                sub_questions: sub_questions,
                totalSubQuestions: sub_questions.length, // C·∫≠p nh·∫≠t l·∫°i t·ªïng s·ªë c√¢u h·ªèi con
                tag: tag,
                timestamp: serverTimestamp()
            };

            try {
                await questionsCollection.doc(q.id).update(updatedData);
                closePassageModal();
                await loadQuestions();
            } catch (error) {
                console.error("L·ªói khi l∆∞u b√†i ƒë·ªçc:", error);
                alert("L·ªói khi l∆∞u b√†i ƒë·ªçc. Ki·ªÉm tra console.");
            }
        }

        async function saveEdit() {
            const q = questions[editIndex];

            const updatedData = {
                question: document.getElementById("editQ").innerHTML,
                choices: [
                    document.getElementById("editC1").value,
                    document.getElementById("editC2").value,
                    document.getElementById("editC3").value,
                    document.getElementById("editC4").value,
                ],
                correct: parseInt(document.getElementById("editCorrect").value) - 1,
                tag: document.getElementById("editTag").value.trim(),
                explanation: document.getElementById("editExplanation").innerHTML.trim(),
                // C·∫≠p nh·∫≠t l·∫°i timestamp
                timestamp: serverTimestamp()
            };

            try {
                // C·∫≠p nh·∫≠t document b·∫±ng ID ƒë√£ l∆∞u (q.id)
                await questionsCollection.doc(q.id).update(updatedData);
                closeModal();
                await loadQuestions(); // T·∫£i l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t hi·ªÉn th·ªã
            } catch (error) {
                console.error("L·ªói khi l∆∞u ch·ªânh s·ª≠a:", error);
                alert("L·ªói khi l∆∞u ch·ªânh s·ª≠a. Ki·ªÉm tra console.");
            }
        }

        // X√≥a (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Firestore)
        async function del(i) {
            if (confirm("X√≥a c√¢u h·ªèi n√†y?")) {
                try {
                    const questionId = questions[i].id;
                    await questionsCollection.doc(questionId).delete();
                    await loadQuestions(); // T·∫£i l·∫°i danh s√°ch
                } catch (error) {
                    console.error("L·ªói khi x√≥a c√¢u h·ªèi:", error);
                    alert("L·ªói khi x√≥a c√¢u h·ªèi. Ki·ªÉm tra console.");
                }
            }
        }

        function closeModal() {
            document.getElementById("editModal").classList.remove("show");
        }

        function closePassageModal() {
            document.getElementById("passageEditModal").classList.remove("show");
        }

        function closePassagePreviewModal() {
            document.getElementById('passagePreviewModal').classList.remove("show");
            tempPassageData = null;
        }

        // Xu·∫•t JSON (D√πng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫£i)
        function exportJSON() {
            // Lo·∫°i b·ªè tr∆∞·ªùng ID Firebase kh·ªèi d·ªØ li·ªáu xu·∫•t
            const exportData = questions.map(({ id, ...rest }) => rest);
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: "application/json",
            });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "questions.json";
            a.click();
        }

        // X√≥a to√†n b·ªô (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Batch Delete)
        async function clearAll() {
            if (confirm("X√≥a to√†n b·ªô c√¢u h·ªèi? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!")) {
                try {
                    // T·∫£i l·∫°i t·∫•t c·∫£ ID l·∫ßn n·ªØa ƒë·ªÉ ƒë·∫£m b·∫£o
                    const snapshot = await questionsCollection.get();
                    if (snapshot.docs.length === 0) return;

                    // D√πng Write Batch ƒë·ªÉ x√≥a nhi·ªÅu document
                    const batch = db.batch();
                    snapshot.docs.forEach((doc) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();

                    questions = [];
                    render();
                    alert("‚úÖ ƒê√£ x√≥a to√†n b·ªô c√¢u h·ªèi th√†nh c√¥ng.");
                } catch (error) {
                    console.error("L·ªói khi x√≥a to√†n b·ªô c√¢u h·ªèi:", error);
                    alert("L·ªói khi x√≥a to√†n b·ªô c√¢u h·ªèi. Ki·ªÉm tra console.");
                }
            }
        }

        // üîπ Format trong modal ch·ªânh s·ª≠a
        function formatEdit(cmd, targetId = 'editQ') {
            const targetDiv = document.getElementById(targetId);
            document.execCommand(cmd, false, null);
            targetDiv.focus();
        }
        function clearFormatEdit() {
            document.execCommand("removeFormat", false, null);
            document.getElementById("editQ").focus();
        }


        // üîπ Format trong v√πng d√°n nhanh
        function formatMulti(cmd, targetId = 'quick') {
            const targetDiv = document.getElementById(targetId);
            if (!targetDiv) return;
            const highlighted = targetDiv.querySelectorAll(
                ".multi-select-highlight"
            );

            if (highlighted.length > 0) {
                document.execCommand("styleWithCSS", false, false);
                highlighted.forEach((span) => {
                    const range = document.createRange();
                    range.selectNodeContents(span);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    document.execCommand(cmd, false, null);
                    selection.removeAllRanges();
                });
            } else {
                document.execCommand(cmd, false, null);
            }
            targetDiv.focus();
        }

        function clearFormatMulti(targetId = 'quick') {
            removeHighlights(targetId);
            document.execCommand("removeFormat", false, null);
            document.getElementById(targetId)?.focus();
        }

        // üîπ Ch·∫ø ƒë·ªô ch·ªçn nhi·ªÅu
        function toggleMultiSelectMode(btn, targetId = 'quick') {
            // T·∫Øt ch·∫ø ƒë·ªô c≈© n·∫øu c√≥
            document.querySelectorAll('#toolbarMulti .active, #toolbarPassage .active').forEach(b => b.classList.remove('active'));

            const isActive = btn.classList.contains('active');
            isMultiSelectMode = !isActive;
            btn.classList.toggle("active", isMultiSelectMode);

            if (!isMultiSelectMode) {
                removeHighlights(targetId);
            }
        }

        function handleMouseUp(e) {
            const targetDiv = e.currentTarget; // ƒê√¢y l√† div contenteditable
            const toolbarId = targetDiv.id.startsWith('edit-preview-q-')
                ? `toolbar-preview-edit-${targetDiv.id.split('-')[3]}`
                : targetDiv.id === 'quick' ? 'toolbarMulti' : 'toolbarPassage';
            const toolbar = document.getElementById(toolbarId);
            if (!toolbar) return;

            const toggleButton = toolbar.querySelector('button.active');
            if (!toggleButton || !toggleButton.classList.contains('active')) return;

            const selection = window.getSelection();
            if (selection.isCollapsed || !selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            if (!targetDiv.contains(range.commonAncestorContainer)) return;

            const span = document.createElement("span");
            span.className = "multi-select-highlight";
            range.surroundContents(span);
            selection.removeAllRanges();
        }

        document.getElementById("quick").addEventListener("mouseup", handleMouseUp);
        document.getElementById("passage-sub-questions").addEventListener("mouseup", handleMouseUp);


        function removeHighlights(targetId = null) {
            const selector = targetId ? `#${targetId} .multi-select-highlight` : '.multi-select-highlight';
            const highlighted = document.querySelectorAll(selector);
            highlighted.forEach((span) => {
                span.replaceWith(...span.childNodes);
            });
            document.getElementById(targetId || 'quick')?.normalize();
        }

        function toggleInputType(type) {
            if (type === 'single') {
                document.getElementById('single-question-form').style.display = 'block';
                document.getElementById('passage-form').style.display = 'none';
            } else if (type === 'passage') {
                document.getElementById('single-question-form').style.display = 'none';
                document.getElementById('passage-form').style.display = 'block';
            }
        }

        // H√†m m·ªõi ƒë·ªÉ l√†m s·∫°ch HTML ƒë∆∞·ª£c d√°n t·ª´ Word
        function sanitizeHtml(html) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            // C√°c th·∫ª HTML ƒë∆∞·ª£c ph√©p gi·ªØ l·∫°i
            const allowedTags = new Set([
                'b', 'strong', 'i', 'em', 'u', 'ins', 's', 'strike', 'del', // ƒê·ªãnh d·∫°ng c∆° b·∫£n: ƒë·∫≠m, nghi√™ng, g·∫°ch ch√¢n, g·∫°ch ngang
                'p', 'br', 'div', 'span', 'ul', 'ol', 'li', // C·∫•u tr√∫c vƒÉn b·∫£n: ƒëo·∫°n vƒÉn, xu·ªëng d√≤ng, kh·ªëi, danh s√°ch
                'h1', 'h2', 'h3', 'h4', 'h5', 'h6', // Ti√™u ƒë·ªÅ
                'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td', // B·∫£ng
                'a', // Li√™n k·∫øt
                // 'img' // C√≥ th·ªÉ th√™m n·∫øu mu·ªën gi·ªØ h√¨nh ·∫£nh, nh∆∞ng c·∫ßn x·ª≠ l√Ω thu·ªôc t√≠nh src
            ]);

            // H√†m ƒë·ªá quy ƒë·ªÉ l√†m s·∫°ch t·ª´ng n√∫t trong c√¢y DOM
            function cleanNode(node) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName.toLowerCase();

                    // X√≥a c√°c thu·ªôc t√≠nh kh√¥ng mong mu·ªën
                    Array.from(node.attributes).forEach(attr => {
                        // Gi·ªØ l·∫°i c√°c thu·ªôc t√≠nh c·∫ßn thi·∫øt cho b·∫£ng v√† li√™n k·∫øt
                        if ((tagName === 'td' || tagName === 'th') && (attr.name === 'colspan' || attr.name === 'rowspan')) {
                            // Gi·ªØ colspan/rowspan cho √¥ b·∫£ng
                        } else if (tagName === 'a' && attr.name === 'href') {
                            // Gi·ªØ href cho th·∫ª <a>
                        }
                        // else if (tagName === 'img' && attr.name === 'src') {
                        //     // Gi·ªØ src cho th·∫ª <img>
                        // }
                        else {
                            node.removeAttribute(attr.name); // X√≥a t·∫•t c·∫£ c√°c thu·ªôc t√≠nh kh√°c (style, class, id, v.v.)
                        }
                    });

                    // Lo·∫°i b·ªè c√°c th·∫ª kh√¥ng ƒë∆∞·ª£c ph√©p, thay th·∫ø b·∫±ng n·ªôi dung b√™n trong c·ªßa ch√∫ng
                    if (!allowedTags.has(tagName)) {
                        while (node.firstChild) {
                            node.parentNode.insertBefore(node.firstChild, node);
                        }
                        node.parentNode.removeChild(node);
                        return; // N√∫t ƒë√£ b·ªã x√≥a, kh√¥ng c·∫ßn x·ª≠ l√Ω con c·ªßa n√≥ n·ªØa
                    }
                }
                // ƒê·ªá quy x·ª≠ l√Ω c√°c n√∫t con
                Array.from(node.childNodes).forEach(cleanNode);
            }
            cleanNode(tempDiv); // B·∫Øt ƒë·∫ßu l√†m s·∫°ch t·ª´ n√∫t g·ªëc
            return tempDiv.innerHTML; // Tr·∫£ v·ªÅ HTML ƒë√£ ƒë∆∞·ª£c l√†m s·∫°ch
        }

        // üîπ X·ª≠ l√Ω d√°n (paste) ƒë·ªÉ lo·∫°i b·ªè ƒë·ªãnh d·∫°ng kh√¥ng mong mu·ªën
        function handlePaste(e) {
            // NgƒÉn ch·∫∑n h√†nh vi d√°n m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát
            e.preventDefault();

            // L·∫•y clipboard data
            const clipboardData = (e.originalEvent || e).clipboardData;

            // ∆Øu ti√™n l·∫•y n·ªôi dung HTML. N·∫øu c√≥, d√°n n√≥.
            // ƒêi·ªÅu n√†y s·∫Ω gi·ªØ l·∫°i c√°c ƒë·ªãnh d·∫°ng nh∆∞ b·∫£ng, in ƒë·∫≠m, v.v.
            let pastedHtml = clipboardData.getData('text/html'); // L·∫•y n·ªôi dung HTML
            if (pastedHtml) pastedHtml = sanitizeHtml(pastedHtml); // L√†m s·∫°ch HTML tr∆∞·ªõc khi d√°n
            if (pastedHtml) {
                document.execCommand('insertHTML', false, pastedHtml);
            } else {
                // N·∫øu kh√¥ng c√≥ HTML, d√°n d∆∞·ªõi d·∫°ng vƒÉn b·∫£n thu·∫ßn
                const pastedText = clipboardData.getData('text/plain');
                document.execCommand('insertText', false, pastedText);
            }
        }

        function startFilteredReview() {
            const searchTerm = document.getElementById("searchInput")?.value.toLowerCase() || "";
            if (!searchTerm) {
                alert("Vui l√≤ng nh·∫≠p t·ª´ kh√≥a t√¨m ki·∫øm ƒë·ªÉ l·ªçc c√¢u h·ªèi tr∆∞·ªõc.");
                return;
            }

            // L·ªçc c√¢u h·ªèi d·ª±a tr√™n t·ª´ kh√≥a t√¨m ki·∫øm (s·ª≠ d·ª•ng logic t∆∞∆°ng t·ª± render())
            const filteredQuestions = questions.filter(q => {
                if (!q) return false;
                let contentToSearch = "";
                if (q.type === 'passage') {
                    contentToSearch = q.passage || "";
                    if (q.sub_questions) {
                        q.sub_questions.forEach(subQ => {
                            contentToSearch += " " + (subQ.question || "");
                            contentToSearch += " " + (subQ.choices ? subQ.choices.join(' ') : "");
                            contentToSearch += " " + (subQ.explanation || "");
                        });
                    }
                } else {
                    contentToSearch = q.question || "";
                    contentToSearch += " " + (q.choices ? q.choices.join(' ') : "");
                    contentToSearch += " " + (q.explanation || "");
                }
                return contentToSearch.replace(/<[^>]+>/g, "").toLowerCase().includes(searchTerm);
            });

            if (filteredQuestions.length === 0) {
                alert("Kh√¥ng t√¨m th·∫•y c√¢u h·ªèi n√†o kh·ªõp v·ªõi t·ª´ kh√≥a c·ªßa b·∫°n.");
                return;
            }

            const filteredIds = filteredQuestions.map(q => q.id);
            sessionStorage.setItem('filteredQuestionIds', JSON.stringify(filteredIds));
            window.location.href = './review.html';
        }

        // G·∫Øn s·ª± ki·ªán paste cho c√°c √¥ contenteditable
        document.getElementById('quick').addEventListener('paste', handlePaste);
        document.getElementById('passage-text').addEventListener('paste', handlePaste);
        document.getElementById('passage-sub-questions').addEventListener('paste', handlePaste);
        document.getElementById('editQ').addEventListener('paste', handlePaste);
        document.getElementById('editQ').addEventListener('mouseup', handleMouseUp);
        document.getElementById('editExplanation').addEventListener('paste', handlePaste);
        document.getElementById('passageEditSubQuestions').addEventListener('paste', handlePaste);
        // G·∫Øn s·ª± ki·ªán paste ƒë·ªông cho c√°c √¥ s·ª≠a trong modal xem tr∆∞·ªõc
        document.getElementById('parsePreviewModal').addEventListener('paste', function(e) {
            if (e.target.isContentEditable) handlePaste(e);
        }, true);


        // üîπ X√≥a n·ªôi dung input
        function clearSingleInput() {
            const quickDiv = document.getElementById('quick');
            if (quickDiv.innerHTML.trim() !== '' && confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô n·ªôi dung ƒë√£ nh·∫≠p?')) {
                quickDiv.innerHTML = '';
            }
        }

        function clearPassageInput() {
            const passageDiv = document.getElementById('passage-text');
            const subQuestionsDiv = document.getElementById('passage-sub-questions');
            if ((passageDiv.innerHTML.trim() !== '' || subQuestionsDiv.innerHTML.trim() !== '') && confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô n·ªôi dung b√†i ƒë·ªçc v√† c√¢u h·ªèi ƒë√£ nh·∫≠p?')) {
                passageDiv.innerHTML = '';
                subQuestionsDiv.innerHTML = '';
            }
        }

        // --- Logic cho n√∫t x√≥a nhanh trong √¥ t√¨m ki·∫øm ---
        const searchInput = document.getElementById("searchInput");
        const clearSearchBtn = document.getElementById("clear-search-btn");

        searchInput.addEventListener("input", () => {
            // Hi·ªÉn th·ªã ho·∫∑c ·∫©n n√∫t 'x'
            clearSearchBtn.style.display = searchInput.value ? 'block' : 'none';
            // render() s·∫Ω ƒë∆∞·ª£c g·ªçi b·ªüi oninput tr√™n th·∫ª input
        });

        clearSearchBtn.addEventListener('click', () => {
            searchInput.value = ''; // X√≥a n·ªôi dung
            clearSearchBtn.style.display = 'none'; // ·∫®n n√∫t 'x'
            render(); // C·∫≠p nh·∫≠t l·∫°i danh s√°ch
            searchInput.focus(); // Tr·∫£ con tr·ªè v·ªÅ √¥ input
        });

        // --- Logic x√≥a h√†ng lo·∫°t ---
        function attachCheckboxListeners() {
            const selectAllCheckbox = document.getElementById('select-all-questions');
            const selectAllPassagesCheckbox = document.getElementById('select-all-passages');
            const singleQuestionCheckboxes = document.querySelectorAll('#single-questions-tbl .question-checkbox');
            const passageCheckboxes = document.querySelectorAll('#passage-questions-tbl .question-checkbox');

            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', (e) => {
                    singleQuestionCheckboxes.forEach(cb => {
                        cb.checked = e.target.checked;
                    });
                    updateBulkActionUI();
                });
            }
            if (selectAllPassagesCheckbox) {
                selectAllPassagesCheckbox.addEventListener('change', (e) => {
                    passageCheckboxes.forEach(cb => {
                        cb.checked = e.target.checked;
                    });
                    updateBulkActionUI();
                });
            }

            singleQuestionCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    updateBulkActionUI();
                });
            });

            passageCheckboxes.forEach(cb => {
                cb.addEventListener('change', () => {
                    updateBulkActionUI();
                });
            });
        }

        function updateBulkActionUI() {
            const selectedCount = document.querySelectorAll('.question-checkbox:checked').length;
            const bulkDeleteBtn = document.getElementById('bulk-delete-btn');

            if (bulkDeleteBtn) {
                bulkDeleteBtn.style.display = selectedCount > 0 ? 'inline-flex' : 'none';
            }

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i cho checkbox "Ch·ªçn t·∫•t c·∫£" c·ªßa c√¢u h·ªèi ƒë∆°n
            updateSelectAllState('select-all-questions', '#single-questions-tbl .question-checkbox');
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i cho checkbox "Ch·ªçn t·∫•t c·∫£" c·ªßa b√†i ƒë·ªçc
            updateSelectAllState('select-all-passages', '#passage-questions-tbl .question-checkbox');
        }

        // H√†m helper ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa m·ªôt checkbox "Ch·ªçn t·∫•t c·∫£"
        function updateSelectAllState(selectAllId, checkboxesSelector) {
            const selectAll = document.getElementById(selectAllId);
            if (!selectAll) return;

            const allCheckboxes = document.querySelectorAll(checkboxesSelector);
            const selectedCheckboxes = document.querySelectorAll(`${checkboxesSelector}:checked`);

            if (allCheckboxes.length === 0) {
                selectAll.checked = false;
                selectAll.indeterminate = false;
            } else {
                if (selectedCheckboxes.length === 0) {
                    selectAll.checked = false;
                    selectAll.indeterminate = false;
                } else if (selectedCheckboxes.length === allCheckboxes.length) {
                    selectAll.checked = true;
                    selectAll.indeterminate = false;
                } else {
                    selectAll.checked = false;
                    selectAll.indeterminate = true;
                }
            }
        }

        function openBulkDeleteModal() {
            const selectedCheckboxes = document.querySelectorAll('.question-checkbox:checked');
            if (selectedCheckboxes.length === 0) return;

            document.getElementById('bulk-delete-count').textContent = selectedCheckboxes.length;
            const listDiv = document.getElementById('bulk-delete-list');
            listDiv.innerHTML = Array.from(selectedCheckboxes).map(cb => {
                const questionId = cb.value;
                const questionData = questions.find(q => q.id === questionId);
                const questionText = questionData?.type === 'passage' ? `[B√†i ƒë·ªçc] ${questionData.passage.substring(0, 50)}...` : (questionData?.question || 'Kh√¥ng r√µ').substring(0, 50);
                return `<li>${questionText}</li>`;
            }).join('');

            document.getElementById('bulkDeleteConfirmModal').classList.add('show');
        }

        function closeBulkDeleteModal() {
            document.getElementById('bulkDeleteConfirmModal').classList.remove('show');
        }

        async function confirmBulkDelete(button) {
            button.disabled = true;
            button.textContent = 'ƒêang x√≥a...';
            const selectedIds = Array.from(document.querySelectorAll('.question-checkbox:checked')).map(cb => cb.value);

            const batch = db.batch();
            selectedIds.forEach(id => {
                batch.delete(questionsCollection.doc(id));
            });

            try {
                await batch.commit();
                alert(`‚úÖ ƒê√£ x√≥a th√†nh c√¥ng ${selectedIds.length} c√¢u h·ªèi.`);
                closeBulkDeleteModal();
                await loadQuestions(); // T·∫£i l·∫°i d·ªØ li·ªáu
            } catch (error) {
                console.error("L·ªói khi x√≥a h√†ng lo·∫°t:", error);
                alert("ƒê√£ x·∫£y ra l·ªói khi x√≥a. Vui l√≤ng th·ª≠ l·∫°i.");
            } finally {
                button.disabled = false;
                button.textContent = 'üóëÔ∏è X√°c nh·∫≠n x√≥a';
            }
        }

        // T·∫£i c√¢u h·ªèi khi trang ƒë∆∞·ª£c load
        loadQuestions();

        // --- Logic cho n√∫t L√™n ƒë·∫ßu trang ---
        const scrollTopBtn = document.getElementById("scrollTopBtn");

        // Khi ng∆∞·ªùi d√πng cu·ªôn trang, ki·ªÉm tra v·ªã tr√≠ ƒë·ªÉ hi·ªÉn th·ªã n√∫t
        window.onscroll = function() {
            if (scrollTopBtn && (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100)) {
                scrollTopBtn.style.display = "block";
            } else {
                scrollTopBtn.style.display = "none";
            }
        };

        // Khi ng∆∞·ªùi d√πng nh·∫•n n√∫t, cu·ªôn l√™n ƒë·∫ßu trang m·ªôt c√°ch m∆∞·ª£t m√†
        function scrollToTop() {
            window.scrollTo({top: 0, behavior: 'smooth'});
        }

    </script>
    </body>

</html>