<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>ÂÖ•Âäõ - ÊñáÊ≥ïÁ∑¥Áøí</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 30px;
            background: #fafafa;
        }

        textarea,
        [contenteditable="true"] {
            width: 100%;
            margin-top: 5px;
            border: 1px solid #ccc;
            background: #fff;
            padding: 8px;
            border-radius: 4px;
        }

        textarea {
            height: 200px;
        }

        button {
            margin: 3px;
            padding: 4px 10px;
            cursor: pointer;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 5px;
            vertical-align: top;
        }

        tr:hover {
            background: #f9f9f9;
        }

        .multi-select-highlight {
            background-color: #fff8b9;
            /* M√†u v√†ng ƒë·ªÉ highlight */
        }

        #multiSelectToggle.active {
            background-color: #a0d2ff;
            /* M√†u xanh khi ch·∫ø ƒë·ªô ƒë∆∞·ª£c b·∫≠t */
            border-color: #6b9ac4;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
            padding: 15px;
            /* Th√™m z-index ƒë·ªÉ ƒë·∫£m b·∫£o modal lu√¥n ·ªü tr√™n c√πng */
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            /* Thay ƒë·ªïi ƒë·ªÉ responsive */
            width: 100%;
            max-width: 500px;
            max-height: 90vh;
            box-sizing: border-box;
            /* Th√™m flex ƒë·ªÉ c·ªë ƒë·ªãnh footer */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .modal-footer {
            padding: 10px 20px;
            border-top: 1px solid #eee;
            text-align: right;
            flex-shrink: 0;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            margin: 5px 0;
            padding: 5px;
        }
    </style>
</head>

<body>
    <h2>üìò Th√™m c√¢u h·ªèi m·ªõi</h2>

    <div id="add-question-area" style="border: 1px solid #ccc; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
        <div>
            <label><input type="radio" name="questionType" value="single" onchange="toggleInputType(this.value)"
                    checked> C√¢u h·ªèi
                ƒë∆°n</label>
            <label style="margin-left: 15px;"><input type="radio" name="questionType" value="passage"
                    onchange="toggleInputType(this.value)"> B√†i ƒë·ªçc (nhi·ªÅu
                c√¢u
                h·ªèi)</label>
        </div>

        <!-- Form cho c√¢u h·ªèi ƒë∆°n -->
        <div id="single-question-form" style="margin-top: 15px;">
            <div id="toolbarMulti" style="margin-bottom: 5px">
                <button id="multiSelectToggle" onclick="toggleMultiSelectMode(this)">‚ú®
                    Ch·ªçn nhi·ªÅu</button>
                <button onclick="formatMulti('bold')"><b>B</b></button>
                <button onclick="formatMulti('underline')"><u>U</u></button>
                <button onclick="formatMulti('strikeThrough')"><s>S</s></button>
                <button onclick="clearFormatMulti()">üßπ Clear</button>
            </div>
            <div id="quick" contenteditable="true" placeholder="D√°n nhi·ªÅu c√¢u h·ªèi ƒë∆°n c√≥ Ê≠£Ëß£ / ‰∏çÊ≠£Ëß£..."
                style="min-height: 200px; white-space: pre-wrap"></div>
            <br />
            <button onclick="quickParse()">‚öôÔ∏è Ph√¢n t√≠ch & L∆∞u c√¢u h·ªèi
                ƒë∆°n</button>
            <button type="button" onclick="clearSingleInput()">üóëÔ∏è X√≥a n·ªôi
                dung</button>
        </div>

        <!-- Form cho b√†i ƒë·ªçc -->
        <div id="passage-form" style="display: none; margin-top: 15px;">
            <label for="passage-text"><b>N·ªôi dung b√†i ƒë·ªçc:</b></label>
            <div id="passage-text" contenteditable="true" placeholder="D√°n n·ªôi dung b√†i ƒë·ªçc v√†o ƒë√¢y..."
                style="min-height: 150px; white-space: pre-wrap"></div>
            <br>
            <label for="passage-sub-questions"><b>C√°c c√¢u h·ªèi cho b√†i
                    ƒë·ªçc:</b></label>
            <!-- Th√™m thanh c√¥ng c·ª• ƒë·ªãnh d·∫°ng cho c√¢u h·ªèi c·ªßa b√†i ƒë·ªçc -->
            <div id="toolbarPassage" style="margin-bottom: 5px">
                <button id="multiSelectTogglePassage" onclick="toggleMultiSelectMode(this, 'passage-sub-questions')">‚ú®
                    Ch·ªçn nhi·ªÅu</button>
                <button onclick="formatMulti('bold', 'passage-sub-questions')"><b>B</b></button>
                <button onclick="formatMulti('underline', 'passage-sub-questions')"><u>U</u></button>
                <button onclick="formatMulti('strikeThrough', 'passage-sub-questions')"><s>S</s></button>
                <button onclick="clearFormatMulti('passage-sub-questions')">üßπ
                    Clear</button>
            </div>
            <div id="passage-sub-questions" contenteditable="true"
                placeholder="D√°n c√°c c√¢u h·ªèi con (1. 2. ...) v√†o ƒë√¢y..."
                style="min-height: 150px; white-space: pre-wrap"></div>
            <br />
            <button onclick="savePassage()">‚öôÔ∏è L∆∞u b√†i ƒë·ªçc & c√°c c√¢u
                h·ªèi</button>
            <button type="button" onclick="clearPassageInput()">üóëÔ∏è X√≥a n·ªôi
                dung</button>
        </div>
    </div>
    <a href="./review.html">üëâ Sang trang √¥n t·∫≠p</a>

    <h2>üìã Danh s√°ch c√¢u h·ªèi</h2>
    <input type="text" id="searchInput" oninput="render()" placeholder="T√¨m ki·∫øm trong c√¢u h·ªèi..."
        style="width: 100%; padding: 8px; margin-bottom: 10px; box-sizing: border-box;">
    <button onclick="exportJSON()">üíæ Xu·∫•t d·ªØ li·ªáu</button>
    <button onclick="clearAll()">üóë X√≥a to√†n b·ªô</button>
    <table id="tbl">
        <thead>
            <tr>
                <th>#</th>
                <th>C√¢u h·ªèi</th>
                <th>Ê≠£Ëß£</th>
                <th>Th·ªëng k√™ (ƒê√∫ng/L·∫ßn l√†m)</th>
                <th>Thao t√°c</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <div class="modal" id="editModal">
        <div class="modal-content">
            <div class="modal-body">
                <h3>‚úèÔ∏è S·ª≠a c√¢u h·ªèi</h3>
                <label>C√¢u h·ªèi:</label>
                <div id="editQ" contenteditable="true" style="
              border: 1px solid #ccc;
              padding: 8px;
              min-height: 60px;
              background: #fff;
              white-space: pre-wrap;
            "></div>

                <div style="margin-top: 6px">
                    <button type="button" onclick="formatEdit('bold')"><b>B</b></button>
                    <button type="button" onclick="formatEdit('underline')">
                        <u>U</u>
                    </button>
                    <button type="button" onclick="formatEdit('strikeThrough')">
                        <s>S</s>
                    </button>
                    <button type="button" onclick="clearFormatEdit()">üßπ
                        Clear</button>
                </div>

                <label>ƒê√°p √°n 1:</label><input type="text" id="editC1" />
                <label>ƒê√°p √°n 2:</label><input type="text" id="editC2" />
                <label>ƒê√°p √°n 3:</label><input type="text" id="editC3" />
                <label>ƒê√°p √°n 4:</label><input type="text" id="editC4" />
                <label>ƒê√∫ng (1-4):</label><input type="number" id="editCorrect" min="1" max="4" />
                <label for="editExplanation">Gi·∫£i th√≠ch (Tham kh·∫£o):</label>
                <textarea id="editExplanation" rows="4" style="width: 100%; margin-top: 5px;"></textarea>
            </div>
            <div class="modal-footer">
                <button onclick="saveEdit()">üíæ L∆∞u</button>
                <button onclick="closeModal()">‚úñ ƒê√≥ng</button>
            </div>
        </div>
    </div>

    <!-- Modal s·ª≠a B√ÄI ƒê·ªåC -->
    <div class="modal" id="passageEditModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-body">
                <h3>‚úèÔ∏è S·ª≠a b√†i ƒë·ªçc</h3>

                <label for="passageEditText"><b>N·ªôi dung b√†i
                        ƒë·ªçc:</b></label>
                <div id="passageEditText" contenteditable="true" style="min-height: 150px; white-space: pre-wrap"></div>
                <br>

                <label for="passageEditSubQuestions"><b>C√°c c√¢u h·ªèi cho b√†i
                        ƒë·ªçc:</b></label>
                <div id="toolbarPassageEdit" style="margin-bottom: 5px">
                    <button onclick="toggleMultiSelectMode(this, 'passageEditSubQuestions')">‚ú®
                        Ch·ªçn nhi·ªÅu</button>
                    <button onclick="formatMulti('bold', 'passageEditSubQuestions')"><b>B</b></button>
                    <button onclick="formatMulti('underline', 'passageEditSubQuestions')"><u>U</u></button>
                    <button onclick="formatMulti('strikeThrough', 'passageEditSubQuestions')"><s>S</s></button>
                    <button onclick="clearFormatMulti('passageEditSubQuestions')">üßπ
                        Clear</button>
                </div>
                <div id="passageEditSubQuestions" contenteditable="true"
                    style="min-height: 200px; white-space: pre-wrap"></div>
            </div>
            <div class="modal-footer">
                <button onclick="savePassageEdit()">üíæ L∆∞u thay ƒë·ªïi</button>
                <button onclick="closePassageModal()">‚úñ ƒê√≥ng</button>
            </div>
        </div>
    </div>
    <div class="modal" id="dupModal">
        <div class="modal-content">
            <div class="modal-body">
                <h3>‚ö†Ô∏è C√¢u h·ªèi tr√πng l·∫∑p</h3>
                <p>Ch·ªçn nh·ªØng c√¢u b·∫°n mu·ªën <b>ghi ƒë√®</b>:</p>
                <div id="dupList" style="margin-top:8px; border:1px solid #ccc; padding:6px; background:#fafafa;"></div>
            </div>
            <div class="modal-footer">
                <button onclick="confirmDup()">‚úÖ X√°c nh·∫≠n</button>
                <button onclick="closeDup()">‚úñ ƒê√≥ng</button>
            </div>
        </div>
    </div>

    <!-- Modal xem tr∆∞·ªõc b√†i ƒë·ªçc -->
    <div class="modal" id="passagePreviewModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-body">
                <h3>üîç Xem tr∆∞·ªõc b√†i ƒë·ªçc & c√¢u h·ªèi</h3>
                <h4>N·ªôi dung b√†i ƒë·ªçc:</h4>
                <div id="previewPassageContent"
                    style="background: #f9f9f9; border: 1px solid #eee; padding: 10px; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                </div>

                <h4 style="margin-top: 20px;">C√°c c√¢u h·ªèi ƒë√£ ph√¢n t√≠ch:</h4>
                <div id="previewSubQuestionsList"></div>
            </div>
            <div class="modal-footer">
                <button onclick="confirmSavePassage()">‚úÖ X√°c nh·∫≠n &
                    L∆∞u</button>
                <button onclick="closePassagePreviewModal()">‚úñ H·ªßy</button>
            </div>
        </div>
    </div>

    <!-- Modal xem tr∆∞·ªõc c√¢u h·ªèi ƒë∆°n -->
    <div class="modal" id="parsePreviewModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-body">
                <h3>üîç Xem tr∆∞·ªõc c√°c c√¢u h·ªèi ƒë√£ ph√¢n t√≠ch</h3>
                <p>Ch·ªçn nh·ªØng c√¢u h·ªèi b·∫°n mu·ªën l∆∞u. B·ªè ch·ªçn nh·ªØng c√¢u ph√¢n t√≠ch sai ho·∫∑c kh√¥ng mu·ªën th√™m.</p>
                <div id="parsePreviewList" style="margin-top: 15px;"></div>
            </div>
            <div class="modal-footer">
                <button onclick="confirmQuickParse()">‚úÖ X√°c nh·∫≠n & L∆∞u c√°c c√¢u ƒë√£ ch·ªçn</button>
                <button onclick="closeParsePreviewModal()">‚úñ H·ªßy</button>
            </div>
        </div>
    </div>


    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <!-- T·∫£i c·∫•u h√¨nh v√† kh·ªüi t·∫°o Firebase t·ª´ file ri√™ng -->
    <script src="./firebase-init.js"></script>

    <script>
        let questions = []; // D·ªØ li·ªáu s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ Firebase
        let editIndex = -1;
        let tempParsedQuestions = []; // L∆∞u c√°c c√¢u h·ªèi ƒë√£ ph√¢n t√≠ch t·∫°m th·ªùi
        let isMultiSelectMode = false;

        // T·∫£i d·ªØ li·ªáu t·ª´ Firestore
        async function loadQuestions() {
            try {
                // T·∫£i c√¢u h·ªèi, s·∫Øp x·∫øp theo timestamp m·ªõi nh·∫•t l√™n ƒë·∫ßu
                const snapshot = await questionsCollection.orderBy("timestamp", "desc").get();
                questions = snapshot.docs.map(doc => ({
                    id: doc.id, // L∆∞u ID c·ªßa document ƒë·ªÉ thao t√°c s·ª≠a/x√≥a
                    ...doc.data()
                }));
                render();
            } catch (error) {
                console.error("L·ªói khi t·∫£i c√¢u h·ªèi:", error);
                alert("L·ªói khi t·∫£i c√¢u h·ªèi. Ki·ªÉm tra console.");
            }
        }

        function render() {
            const searchTerm = document.getElementById("searchInput")?.value.toLowerCase() || "";
            const tbody = document.querySelector("#tbl tbody");
            tbody.innerHTML = "";

            const filteredQuestions = questions.filter(q => {
                // T√¨m ki·∫øm tr√™n n·ªôi dung text c·ªßa c√¢u h·ªèi, kh√¥ng bao g·ªìm HTML
                if (!q) return false;
                let contentToSearch = "";
                if (q.type === 'passage') {
                    // ƒê·ªëi v·ªõi b√†i ƒë·ªçc, t√¨m ki·∫øm trong n·ªôi dung b√†i ƒë·ªçc
                    contentToSearch = q.passage || "";
                } else {
                    // ƒê·ªëi v·ªõi c√¢u h·ªèi ƒë∆°n, t√¨m ki·∫øm trong n·ªôi dung c√¢u h·ªèi
                    contentToSearch = q.question || "";
                }
                return contentToSearch.replace(/<[^>]+>/g, "").toLowerCase().includes(searchTerm);
            });

            // T√°ch th√†nh 2 nh√≥m
            const passages = filteredQuestions.filter(q => q.type === 'passage');
            const singles = filteredQuestions.filter(q => q.type !== 'passage');

            // Hi·ªÉn th·ªã nh√≥m B√†i ƒë·ªçc
            if (passages.length > 0) {
                const headerRow = tbody.insertRow();
                headerRow.innerHTML = `<th colspan="5" style="background-color: #eef; text-align: left;">üìö B√†i ƒë·ªçc (${passages.length})</th>`;
                passages.forEach((q, index) => renderRow(q, index));
            }

            // Hi·ªÉn th·ªã nh√≥m C√¢u h·ªèi ƒë∆°n
            if (singles.length > 0) {
                const headerRow = tbody.insertRow();
                headerRow.innerHTML = `<th colspan="5" style="background-color: #eff; text-align: left;">üìù C√¢u h·ªèi ƒë∆°n (${singles.length})</th>`;
                singles.forEach((q, index) => renderRow(q, index));
            }

            // H√†m ph·ª• ƒë·ªÉ render m·ªôt d√≤ng
            function renderRow(q, displayIndex) {
                // T√¨m index g·ªëc c·ªßa c√¢u h·ªèi trong m·∫£ng `questions` ƒë·ªÉ c√°c h√†m s·ª≠a/x√≥a ho·∫°t ƒë·ªông ƒë√∫ng
                const originalIndex = questions.findIndex(originalQ => originalQ.id === q.id);
                if (originalIndex === -1) return; // B·ªè qua n·∫øu kh√¥ng t√¨m th·∫•y

                const tr = document.createElement("tr");
                if (q.type === 'passage' && q.sub_questions) {
                    const totalAttemptedSubQuestions = (q.attempts || 0) * (q.totalSubQuestions || q.sub_questions.length);
                    tr.innerHTML = `
                        <td>${displayIndex + 1}</td>
                        <td>
                            <div style="font-weight: bold; color: #005a9e;">[B√ÄI ƒê·ªåC]</div>
                            <div>${q.passage.substring(0, 150)}... (${q.sub_questions.length} c√¢u h·ªèi)</div>
                        </td>
                        <td>-</td>
                        <td style="text-align: center;">${q.correctAttempts || 0}/${totalAttemptedSubQuestions}</td>
                        <td><button onclick="openEdit(${originalIndex})">S·ª≠a</button><button onclick="del(${originalIndex})">X√≥a</button></td>`;
                } else { // M·∫∑c ƒë·ªãnh l√† c√¢u h·ªèi ƒë∆°n
                    tr.innerHTML = `
                        <td>${displayIndex + 1}</td>
                        <td>${q.question}</td>
                        <td>${q.choices[q.correct] || ""}</td>
                        <td style="text-align: center;">${q.correctAttempts || 0}/${q.attempts || 0}</td>
                        <td><button onclick="openEdit(${originalIndex})">S·ª≠a</button><button onclick="del(${originalIndex})">X√≥a</button></td>`;
                }
                tbody.appendChild(tr);
            }
        }

        let tempDup = []; // l∆∞u danh s√°ch tr√πng t·∫°m
        let tempPassageData = null; // D·ªØ li·ªáu b√†i ƒë·ªçc t·∫°m th·ªùi cho vi·ªác xem tr∆∞·ªõc

        // üîπ H√†m t√°i s·ª≠ d·ª•ng ƒë·ªÉ ph√¢n t√≠ch c√¢u h·ªèi t·ª´ HTML (ƒê√É S·ª¨A HO√ÄN TO√ÄN)
        function parseQuestionsFromHTML(html) {
            const questions = [];
            if (!html) return questions;

            const safeHTML = html
                .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "")
                .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "");

            // Chu·∫©n h√≥a v√† t√°ch d√≤ng - GI·ªÆ NGUY√äN ƒê·ªäNH D·∫†NG HTML
            const allLines = safeHTML
                .replace(/<div>/g, "\n")
                .replace(/<\/div>/g, "")
                .replace(/<br\s*\/?>/gi, "\n")
                .replace(/<\/p>/gi, "\n")
                .split("\n")
                .map(x => x.trim())
                .filter(x => x);

            // Ph√¢n t√≠ch theo t·ª´ng kh·ªëi c√¢u h·ªèi d·ª±a tr√™n s·ªë th·ª© t·ª±
            let currentBlock = [];
            let blocks = [];

            allLines.forEach(line => {
                // Ph√°t hi·ªán b·∫Øt ƒë·∫ßu c√¢u h·ªèi m·ªõi: s·ªë theo sau b·ªüi d·∫•u ch·∫•m
                if (line.match(/^\s*\d+\.\s/) || line.match(/^\s*\d+\s*$/)) {
                    if (currentBlock.length > 0) {
                        blocks.push([...currentBlock]);
                        currentBlock = [];
                    }
                }
                currentBlock.push(line);
            });

            if (currentBlock.length > 0) {
                blocks.push(currentBlock);
            }

            // Ph√¢n t√≠ch t·ª´ng kh·ªëi
            blocks.forEach(block => {
                const question = parseSingleQuestionBlock(block);
                if (question) {
                    questions.push(question);
                }
            });

            return questions;
        }

        // üîπ H√†m ph√¢n t√≠ch m·ªôt kh·ªëi c√¢u h·ªèi ƒë∆°n l·∫ª
        function parseSingleQuestionBlock(blockLines) {
            if (blockLines.length === 0) return null;

            let questionText = "";
            const choices = [];
            let correctAnswer = -1;
            let explanation = "";

            // X√°c ƒë·ªãnh d√≤ng ƒë·∫ßu ti√™n (c√¢u h·ªèi ch√≠nh)
            const firstLine = blockLines[0];
            // Lo·∫°i b·ªè s·ªë th·ª© t·ª± ·ªü ƒë·∫ßu d√≤ng
            questionText = firstLine.replace(/^\s*\d+\.?\s*/, "");

            // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p ch·ªâ c√≥ s·ªë th·ª© t·ª±, kh√¥ng c√≥ n·ªôi dung c√¢u h·ªèi
            if (!questionText.trim()) {
                questionText = `(C√¢u h·ªèi ${firstLine.replace(/\D/g, "")})`;
            }

            // Bi·∫øn t·∫°m ƒë·ªÉ thu th·∫≠p c√°c d√≤ng ti·∫øp theo c·ªßa c√¢u h·ªèi
            let collectingQuestion = true;
            let tempQuestionLines = [questionText];
            
            // ƒê·∫øm s·ªë l·ª±a ch·ªçn ƒë√£ t√¨m th·∫•y ƒë·ªÉ x√°c ƒë·ªãnh khi n√†o d·ª´ng thu th·∫≠p c√¢u h·ªèi
            let choicesFoundCount = 0;

            // Duy·ªát c√°c d√≤ng c√≤n l·∫°i
            for (let i = 1; i < blockLines.length; i++) {
                const line = blockLines[i];

                // Ki·ªÉm tra c√°c pattern ƒë·∫∑c bi·ªát tr∆∞·ªõc

                // 1. D√≤ng ƒë√°p √°n ƒë√∫ng: "Ê≠£Ëß£: X) N·ªôi dung" ho·∫∑c "Ê≠£Ëß£: X"
                const correctLineMatch = line.match(/Ê≠£Ëß£\s*[:Ôºö]\s*(\d+)\)\s*(.*)/);
                if (correctLineMatch) {
                    correctAnswer = parseInt(correctLineMatch[1]) - 1;
                    const choiceText = correctLineMatch[2].trim();
                    if (choiceText) {
                        choices[correctAnswer] = choiceText;
                    }
                    // N·∫øu ƒë√£ t√¨m th·∫•y √≠t nh·∫•t 2 l·ª±a ch·ªçn, c√≥ th·ªÉ ch·∫Øc ch·∫Øn ƒë√¢y kh√¥ng ph·∫£i l√† m·ªôt ph·∫ßn c·ªßa c√¢u h·ªèi n·ªØa.
                    if (choices.filter(c => c).length >= 2) {
                        collectingQuestion = false;
                    }
                    continue;
                }

                // 2. D√≤ng ƒë√°p √°n ƒë∆°n gi·∫£n: "Ê≠£Ëß£: X"
                const correctSimpleMatch = line.match(/Ê≠£Ëß£\s*[:Ôºö]\s*(\d+)\s*$/);
                if (correctSimpleMatch) {
                    correctAnswer = parseInt(correctSimpleMatch[1]) - 1;
                    if (choices.filter(c => c).length >= 2) {
                        collectingQuestion = false;
                    }
                    continue;
                }

                // 3. D√≤ng ƒë√°p √°n sai: "‰∏çÊ≠£Ëß£: X) N·ªôi dung"
                const incorrectLineMatch = line.match(/‰∏çÊ≠£Ëß£\s*[:Ôºö]\s*(\d+)\)\s*(.*)/);
                if (incorrectLineMatch) {
                    const choiceIndex = parseInt(incorrectLineMatch[1]) - 1;
                    const choiceText = incorrectLineMatch[2].trim();
                    choices[choiceIndex] = choiceText;
                    if (choices.filter(c => c).length >= 2) {
                        collectingQuestion = false;
                    }
                    continue;
                }

                // 4. L·ª±a ch·ªçn th√¥ng th∆∞·ªùng: "X) N·ªôi dung"
                const choiceMatch = line.match(/^\s*(\d+)\)\s*(.*)/);
                if (choiceMatch) {
                    const choiceIndex = parseInt(choiceMatch[1]) - 1;
                    let choiceText = choiceMatch[2].trim();

                    // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p c√≥ "Ê≠£Ëß£" trong l·ª±a ch·ªçn
                    if (choiceText.includes("Ê≠£Ëß£")) {
                        correctAnswer = choiceIndex;
                        choiceText = choiceText.replace(/\s*Ê≠£Ëß£\s*/, "").trim();
                    }
                    // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p c√≥ "‰∏çÊ≠£Ëß£" trong l·ª±a ch·ªçn
                    if (choiceText.includes("‰∏çÊ≠£Ëß£")) {
                        choiceText = choiceText.replace(/\s*‰∏çÊ≠£Ëß£\s*/, "").trim();
                    }

                    choices[choiceIndex] = choiceText;
                    choicesFoundCount++;

                    // Ch·ªâ d·ª´ng thu th·∫≠p c√¢u h·ªèi khi ƒë√£ t√¨m th·∫•y √≠t nh·∫•t 2 l·ª±a ch·ªçn.
                    if (choicesFoundCount >= 2) {
                        collectingQuestion = false;
                    }
                    continue;
                }

                // 5. Gi·∫£i th√≠ch
                const explanationMatch = line.match(/^(Tham kh·∫£o|Gi·∫£i th√≠ch|ÂèÇËÄÉ)\s*[:Ôºö]\s*(.*)/i);
                if (explanationMatch) {
                    explanation = explanationMatch[2].trim();
                    collectingQuestion = false;
                    continue;
                }

                // 6. N·∫øu kh√¥ng kh·ªõp v·ªõi pattern n√†o v√† v·∫´n ƒëang thu th·∫≠p c√¢u h·ªèi
                if (collectingQuestion) {
                    tempQuestionLines.push(line);
                }
            }

            // Gh√©p c√°c d√≤ng c√¢u h·ªèi l·∫°i
            questionText = tempQuestionLines.join("<br>");

            // ƒêi·ªÅn c√°c l·ª±a ch·ªçn c√≤n thi·∫øu (n·∫øu c√≥)
            for (let i = 0; i < 4; i++) {
                if (!choices[i]) {
                    choices[i] = "";
                }
            }

            // N·∫øu kh√¥ng t√¨m th·∫•y d√≤ng "Ê≠£Ëß£" n√†o, gi·∫£ ƒë·ªãnh l·ª±a ch·ªçn ƒë·∫ßu ti√™n l√† ƒë√∫ng
            if (correctAnswer === -1 && choices.filter(c => c && c.trim() !== "").length > 0) {
                correctAnswer = 0;
            }

            // Ch·ªâ tr·∫£ v·ªÅ c√¢u h·ªèi n·∫øu c√≥ √≠t nh·∫•t 2 l·ª±a ch·ªçn v√† ƒë√°p √°n ƒë√∫ng ƒë∆∞·ª£c x√°c ƒë·ªãnh
            const filledChoices = choices.filter(c => c && c.trim() !== "");
            if (filledChoices.length >= 2 && correctAnswer !== -1 && correctAnswer < choices.length) {
                return {
                    question: questionText,
                    choices: choices,
                    correct: correctAnswer,
                    explanation: explanation
                };
            }

            return null;
        }
        // üîπ H√†m ph·ª• ƒë·ªÉ ph√¢n t√≠ch m·ªôt c√¢u h·ªèi duy nh·∫•t t·ª´ n·ªôi dung
        function parseSingleQuestionFromContent(lines) {
            const question = {
                question: "",
                choices: [],
                correct: -1,
                explanation: ""
            };

            let foundChoices = false;
            let questionLines = [];

            lines.forEach(line => {
                // X√°c ƒë·ªãnh d√≤ng c√¢u h·ªèi (kh√¥ng ph·∫£i l·ª±a ch·ªçn v√† kh√¥ng ph·∫£i ƒë√°p √°n)
                const isChoice = line.match(/^\s*(\d+)\)/);
                const isCorrectAnswer = line.match(/Ê≠£Ëß£\s*[:Ôºö]?\s*(\d+)/);
                const isIncorrectMarker = line.match(/‰∏çÊ≠£Ëß£\s*[:Ôºö]?\s*(\d+\))/);

                if (!isChoice && !isCorrectAnswer && !isIncorrectMarker && !foundChoices) {
                    questionLines.push(line);
                } else {
                    foundChoices = true;

                    // X·ª≠ l√Ω l·ª±a ch·ªçn
                    const choiceMatch = line.match(/^\s*(\d+)\)\s*(.*)/);
                    if (choiceMatch) {
                        const choiceNum = parseInt(choiceMatch[1]);
                        let choiceText = choiceMatch[2].trim();

                        // X·ª≠ l√Ω "‰∏çÊ≠£Ëß£" ·ªü ƒë·∫ßu
                        if (choiceText.startsWith("‰∏çÊ≠£Ëß£")) {
                            choiceText = choiceText.replace(/^‰∏çÊ≠£Ëß£\s*[:Ôºö]?\s*/, "");
                        }

                        // X·ª≠ l√Ω "Ê≠£Ëß£" trong l·ª±a ch·ªçn
                        if (choiceText.includes("Ê≠£Ëß£")) {
                            question.correct = choiceNum - 1;
                            choiceText = choiceText.replace(/\s*Ê≠£Ëß£\s*$/, "").replace(/\s*Ê≠£Ëß£\s*[:Ôºö]\s*/, "");
                        }

                        question.choices[choiceNum - 1] = choiceText;
                    }

                    // X·ª≠ l√Ω ƒë√°p √°n ƒë√∫ng ri√™ng bi·ªát
                    const correctMatch = line.match(/Ê≠£Ëß£\s*[:Ôºö]?\s*(\d+)/);
                    if (correctMatch) {
                        question.correct = parseInt(correctMatch[1]) - 1;
                    }
                }
            });

            question.question = questionLines.join("<br>");

            // N·∫øu v·∫´n kh√¥ng c√≥ c√¢u h·ªèi, s·ª≠ d·ª•ng d√≤ng ƒë·∫ßu ti√™n
            if (!question.question && lines.length > 0) {
                question.question = lines[0];
            }

            return question.choices.length >= 2 && question.correct !== -1 ? [question] : [];
        }

        function populateAndShowParsePreviewModal(parsedQuestions) {
            tempParsedQuestions = parsedQuestions;
            const previewList = document.getElementById('parsePreviewList');
            previewList.innerHTML = ""; // X√≥a n·ªôi dung c≈©

            parsedQuestions.forEach((q, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.id = `preview-item-${index}`;
                itemDiv.style = "border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px; background: #f9f9f9;";
                itemDiv.innerHTML = getParsedQuestionHTML(q, index);
                previewList.appendChild(itemDiv);
            });

            document.getElementById('parsePreviewModal').style.display = 'flex';
        }

        function getParsedQuestionHTML(q, index, isEditing = false) {
            if (isEditing) {
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: bold;"><input type="checkbox" class="parse-preview-checkbox" data-index="${index}" checked> C√¢u h·ªèi ${index + 1}</label>
                        <button onclick="saveParsedQuestionEdit(${index})">üíæ L∆∞u</button>
                    </div>
                    <div id="toolbar-preview-edit-${index}" style="margin-bottom: 5px; border: 1px solid #eee; padding: 3px; border-radius: 4px;">
                        <button onclick="toggleMultiSelectMode(this, 'edit-preview-q-${index}')" title="Ch·ªçn nhi·ªÅu">‚ú®</button>
                        <button onclick="formatMulti('bold', 'edit-preview-q-${index}')"><b>B</b></button>
                        <button onclick="formatMulti('underline', 'edit-preview-q-${index}')"><u>U</u></button>
                        <button onclick="formatMulti('strikeThrough', 'edit-preview-q-${index}')"><s>S</s></button>
                        <button onclick="clearFormatMulti('edit-preview-q-${index}')" title="X√≥a ƒë·ªãnh d·∫°ng">üßπ</button>
                    </div>
                    <div contenteditable="true" id="edit-preview-q-${index}" style="border: 1px dashed #ccc; padding: 5px; margin-bottom: 5px; background: white;">${q.question}</div>
                    ${[0, 1, 2, 3].map(cIndex => `
                        <div style="display: flex; align-items: center; margin-bottom: 3px;">
                            <span style="margin-right: 5px;">${cIndex + 1})</span>
                            <input type="text" id="edit-preview-c-${index}-${cIndex}" value="${q.choices[cIndex] || ''}" style="flex-grow: 1; padding: 3px;">
                        </div>
                    `).join('')}
                    <div style="display: flex; align-items: center; margin-top: 5px;">
                        <label for="edit-preview-correct-${index}" style="margin-right: 5px;">ƒê√°p √°n ƒë√∫ng (1-4):</label>
                        <input type="number" id="edit-preview-correct-${index}" value="${q.correct + 1}" min="1" max="4" style="width: 60px;">
                    </div>
                     <div style="margin-top: 5px;">
                        <label for="edit-preview-explanation-${index}" style="display:block; margin-bottom: 3px;">Gi·∫£i th√≠ch:</label>
                        <textarea id="edit-preview-explanation-${index}" style="width: 100%; font-size: 13px;" rows="2">${q.explanation || ''}</textarea>
                    </div>
                `;
            } else {
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="font-weight: bold; flex-grow: 1;">
                            <input type="checkbox" class="parse-preview-checkbox" data-index="${index}" checked>
                            C√¢u h·ªèi ${index + 1}: ${q.question}
                        </label>
                        <button onclick="editParsedQuestion(${index})">‚úèÔ∏è S·ª≠a</button>
                    </div>
                    <ul>
                        ${q.choices.map((choice, cIndex) => `
                            <li style="${cIndex === q.correct ? 'font-weight: bold; color: green;' : ''}">
                                ${cIndex + 1}) ${choice}
                            </li>
                        `).join('')}
                    </ul>
                    ${q.explanation ? `<div style="margin-top: 8px; padding: 5px; background-color: #e9e9e9; border-radius: 3px;"><b>Gi·∫£i th√≠ch:</b> ${q.explanation}</div>` : ''}
                `;
            }
        }

        function editParsedQuestion(index) {
            const q = tempParsedQuestions[index];
            const itemDiv = document.getElementById(`preview-item-${index}`);
            itemDiv.innerHTML = getParsedQuestionHTML(q, index, true);
            // G·∫Øn s·ª± ki·ªán ƒë·ªÉ ch·∫ø ƒë·ªô "Ch·ªçn nhi·ªÅu" ho·∫°t ƒë·ªông
            document.getElementById(`edit-preview-q-${index}`).addEventListener("mouseup", handleMouseUp);
        }

        function saveParsedQuestionEdit(index) {
            const q = tempParsedQuestions[index];
            // X√≥a c√°c highlight c·ªßa ch·∫ø ƒë·ªô "Ch·ªçn nhi·ªÅu" tr∆∞·ªõc khi l∆∞u
            removeHighlights(`edit-preview-q-${index}`);
            q.question = document.getElementById(`edit-preview-q-${index}`).innerHTML;
            q.choices = [0, 1, 2, 3].map(cIndex => document.getElementById(`edit-preview-c-${index}-${cIndex}`).value);
            q.correct = parseInt(document.getElementById(`edit-preview-correct-${index}`).value) - 1;
            q.explanation = document.getElementById(`edit-preview-explanation-${index}`).value;

            const itemDiv = document.getElementById(`preview-item-${index}`);
            itemDiv.innerHTML = getParsedQuestionHTML(q, index, false);
            // ƒê·∫£m b·∫£o checkbox v·∫´n ƒë∆∞·ª£c ch·ªçn sau khi l∆∞u
            itemDiv.querySelector('.parse-preview-checkbox').checked = true;
        }

        function closeParsePreviewModal() {
            document.getElementById('parsePreviewModal').style.display = 'none';
            tempParsedQuestions = [];
        }

        // üîπ Ph√¢n t√≠ch nhi·ªÅu c√¢u h·ªèi (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Firestore)
        async function quickParse() {
            const html = document.getElementById("quick").innerHTML.trim();
            if (!html) return alert("H√£y d√°n n·ªôi dung!");

            const safeHTML = html
                .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "")
                .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "");

            const parsed = parseQuestionsFromHTML(safeHTML);
            const newQuestions = parsed.map(q => ({ ...q, type: 'single', attempts: 0, correctAttempts: 0 }));

            if (newQuestions.length === 0) {
                alert("‚ö†Ô∏è Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi n√†o!");
                return;
            }

            // Hi·ªÉn th·ªã modal xem tr∆∞·ªõc thay v√¨ x·ª≠ l√Ω ngay
            populateAndShowParsePreviewModal(newQuestions);
        }

        async function confirmQuickParse() {
            const selectedCheckboxes = document.querySelectorAll('.parse-preview-checkbox:checked');
            const selectedQuestions = Array.from(selectedCheckboxes).map(cb => {
                const index = parseInt(cb.getAttribute('data-index'));
                return tempParsedQuestions[index];
            });

            if (selectedQuestions.length === 0) {
                alert("B·∫°n ch∆∞a ch·ªçn c√¢u h·ªèi n√†o ƒë·ªÉ l∆∞u.");
                return;
            }
            const current = questions; // D√πng bi·∫øn questions ƒë√£ load t·ª´ Firestore
            const duplicates = [];
            const unique = [];

            for (const nq of selectedQuestions) {
                const dup = current.find(q =>
                    // Ch·ªâ so s√°nh n·∫øu q l√† c√¢u h·ªèi ƒë∆°n v√† c√≥ thu·ªôc t√≠nh 'question'
                    q.type !== 'passage' && q.question &&
                    q.question.replace(/<[^>]+>/g, "").trim() === nq.question.replace(/<[^>]+>/g, "").trim()
                );
                if (dup) {
                    duplicates.push({ ...nq, oldId: dup.id }); // L∆∞u c·∫£ ID c≈© ƒë·ªÉ ghi ƒë√®
                }
                else {
                    unique.push(nq);
                }
            }

            if (duplicates.length > 0) {
                tempDup = { duplicates, unique }; // Kh√¥ng c·∫ßn current v√¨ ƒë√£ c√≥ ID
                const list = document.getElementById("dupList");
                list.innerHTML = duplicates.map((q, i) => `
            <div style="margin-bottom:8px; background:#fff; padding:6px; border-radius:4px;">
              <label>
                <input type="checkbox" checked id="dup_${i}" />
                <span>${q.question}</span>
              </label>
            </div>
          `).join("");
                document.getElementById("dupModal").style.display = "flex";
            } else {
                // L∆∞u t·∫•t c·∫£ c√¢u h·ªèi m·ªõi v√†o Firestore
                await Promise.all(unique.map(q => questionsCollection.add({
                    ...q,
                    timestamp: serverTimestamp()
                    // attempts v√† correctAttempts ƒë√£ ƒë∆∞·ª£c th√™m ·ªü tr√™n
                }))).then(() => {
                    alert(`‚úÖ ƒê√£ th√™m ${unique.length} c√¢u h·ªèi m·ªõi (gi·ªØ ƒë·ªãnh d·∫°ng HTML).`);
                });
                closeParsePreviewModal();
                await loadQuestions(); // T·∫£i l·∫°i danh s√°ch
            }
        }

        async function confirmDup() {
            const { duplicates, unique } = tempDup;
            const selected = [];
            const newUnique = [];
            let updatedCount = 0;
            let addedCount = 0;

            // 1. X·ª≠ l√Ω c√°c c√¢u h·ªèi tr√πng l·∫∑p ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ ghi ƒë√® (UPDATE)
            const updatePromises = [];
            duplicates.forEach((q, i) => {
                const cb = document.getElementById(`dup_${i}`);
                if (cb && cb.checked) {
                    // Ghi ƒë√® c√¢u h·ªèi c≈© b·∫±ng d·ªØ li·ªáu m·ªõi, d√πng ID c≈© (q.oldId)
                    updatePromises.push(questionsCollection.doc(q.oldId).update({
                        question: q.question,
                        choices: q.choices,
                        correct: q.correct,
                        timestamp: serverTimestamp()
                        // Kh√¥ng reset attempts khi ghi ƒë√®, ch·ªâ c·∫≠p nh·∫≠t n·ªôi dung
                    }));
                    updatedCount++;
                }
            });

            // 2. X·ª≠ l√Ω c√°c c√¢u h·ªèi ho√†n to√†n m·ªõi (ADD)
            const addPromises = unique.map(q => {
                addedCount++;
                return questionsCollection.add({
                    ...q,
                    timestamp: serverTimestamp()
                });
            });

            await Promise.all([...updatePromises, ...addPromises]);
            await loadQuestions(); // T·∫£i l·∫°i danh s√°ch

            closeDup();

            alert(`‚úÖ ƒê√£ ho√†n th√†nh. ƒê√£ ghi ƒë√® ${updatedCount} c√¢u h·ªèi v√† th√™m ${addedCount} c√¢u h·ªèi m·ªõi.`);
        }

        // üîπ L∆∞u b√†i ƒë·ªçc
        async function savePassage() {
            const passageHTML = document.getElementById("passage-text").innerHTML.trim();
            const subQuestionsHTML = document.getElementById("passage-sub-questions").innerHTML.trim();

            if (!passageHTML) return alert("Vui l√≤ng nh·∫≠p n·ªôi dung b√†i ƒë·ªçc.");
            if (!subQuestionsHTML) return alert("Vui l√≤ng nh·∫≠p c√°c c√¢u h·ªèi cho b√†i ƒë·ªçc.");

            const sub_questions = parseQuestionsFromHTML(subQuestionsHTML);

            if (sub_questions.length === 0) {
                return alert("Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi con n√†o. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng.");
            }

            // L∆∞u d·ªØ li·ªáu t·∫°m th·ªùi ƒë·ªÉ x√°c nh·∫≠n
            tempPassageData = {
                type: 'passage',
                passage: passageHTML,
                sub_questions: sub_questions,
                attempts: 0,
                correctAttempts: 0,
                totalSubQuestions: sub_questions.length, // Th√™m t·ªïng s·ªë c√¢u h·ªèi con
            };

            // Hi·ªÉn th·ªã modal xem tr∆∞·ªõc
            populateAndShowPreviewModal();
        }

        async function confirmSavePassage() {
            if (!tempPassageData) return;

            const passageData = {
                ...tempPassageData,
                timestamp: serverTimestamp()
            };

            try {
                await questionsCollection.add(passageData);
                alert(`‚úÖ ƒê√£ l∆∞u b√†i ƒë·ªçc v·ªõi ${passageData.sub_questions.length} c√¢u h·ªèi th√†nh c√¥ng!`);
                document.getElementById("passage-text").innerHTML = "";
                document.getElementById("passage-sub-questions").innerHTML = "";
                closePassagePreviewModal();
                await loadQuestions();
            } catch (error) {
                console.error("L·ªói khi l∆∞u b√†i ƒë·ªçc:", error);
                alert("ƒê√£ x·∫£y ra l·ªói khi l∆∞u b√†i ƒë·ªçc. Vui l√≤ng ki·ªÉm tra console.");
            }
        }

        function populateAndShowPreviewModal() {
            if (!tempPassageData) return;

            document.getElementById('previewPassageContent').innerHTML = tempPassageData.passage;

            const previewList = document.getElementById('previewSubQuestionsList');
            previewList.innerHTML = tempPassageData.sub_questions.map((sq, index) => `
                <div style="border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
                    <p><b>C√¢u h·ªèi ${index + 1}:</b> ${sq.question}</p>
                    <ul>
                        ${sq.choices.map((choice, cIndex) => `
                            <li style="${cIndex === sq.correct ? 'font-weight: bold; color: green;' : ''}">
                                ${cIndex + 1}) ${choice} ${cIndex === sq.correct ? '<b>(ƒê√°p √°n ƒë√∫ng)</b>' : ''}
                            </li>
                        `).join('')}
                    </ul>
                    ${sq.explanation ? `<div style="margin-top: 8px; padding: 5px; background-color: #f0f0f0; border-radius: 3px;"><b>Gi·∫£i th√≠ch:</b> ${sq.explanation}</div>` : ''}
                </div>
            `).join('');

            document.getElementById('passagePreviewModal').style.display = 'flex';
        }

        function closeDup() {
            document.getElementById("dupModal").style.display = "none";
            tempDup = [];
        }

        // üîπ Ch·ªânh s·ª≠a (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Firestore)
        function openEdit(i) {
            editIndex = i;
            const q = questions[i];

            if (q.type === 'passage') {
                document.getElementById("passageEditText").innerHTML = q.passage;
                document.getElementById("passageEditSubQuestions").innerHTML = formatSubQuestionsForEditing(q.sub_questions);
                document.getElementById("passageEditModal").style.display = "flex";
            } else {
                document.getElementById("editQ").innerHTML = q.question;
                document.getElementById("editC1").value = q.choices[0] || "";
                document.getElementById("editC2").value = q.choices[1] || "";
                document.getElementById("editC3").value = q.choices[2] || "";
                document.getElementById("editC4").value = q.choices[3] || "";
                document.getElementById("editCorrect").value = q.correct + 1;
                document.getElementById("editExplanation").value = q.explanation || ""; // Hi·ªÉn th·ªã gi·∫£i th√≠ch c≈©
                document.getElementById("editModal").style.display = "flex";
            }
        }

        // Helper ƒë·ªÉ format c√¢u h·ªèi con cho vi·ªác s·ª≠a
        function formatSubQuestionsForEditing(subQuestions) {
            if (!subQuestions) return "";
            return subQuestions.map((sq, index) => {
                const choicesStr = sq.choices.map((choice, cIndex) => `${cIndex + 1}) ${choice}`).join('\n');
                const correctStr = `Ê≠£Ëß£: ${sq.correct + 1}`;
                const explanationStr = sq.explanation ? `\nTham kh·∫£o: ${sq.explanation}` : '';
                return `${index + 1}. ${sq.question}\n${choicesStr}\n${correctStr}${explanationStr}`;
            }).join('\n\n'); // Th√™m d√≤ng tr·ªëng gi·ªØa c√°c c√¢u h·ªèi
        }

        // L∆∞u ch·ªânh s·ª≠a cho B√ÄI ƒê·ªåC
        async function savePassageEdit() {
            const q = questions[editIndex];
            const passageHTML = document.getElementById("passageEditText").innerHTML.trim();
            const subQuestionsHTML = document.getElementById("passageEditSubQuestions").innerHTML.trim();

            if (!passageHTML || !subQuestionsHTML) {
                return alert("N·ªôi dung b√†i ƒë·ªçc v√† c√¢u h·ªèi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.");
            }

            const sub_questions = parseQuestionsFromHTML(subQuestionsHTML);
            if (sub_questions.length === 0) {
                return alert("Kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c c√¢u h·ªèi con n√†o. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë·ªãnh d·∫°ng.");
            }

            const updatedData = {
                passage: passageHTML,
                sub_questions: sub_questions,
                totalSubQuestions: sub_questions.length, // C·∫≠p nh·∫≠t l·∫°i t·ªïng s·ªë c√¢u h·ªèi con
                timestamp: serverTimestamp()
            };

            try {
                await questionsCollection.doc(q.id).update(updatedData);
                closePassageModal();
                await loadQuestions();
            } catch (error) {
                console.error("L·ªói khi l∆∞u b√†i ƒë·ªçc:", error);
                alert("L·ªói khi l∆∞u b√†i ƒë·ªçc. Ki·ªÉm tra console.");
            }
        }

        async function saveEdit() {
            const q = questions[editIndex];

            if (q.type === 'passage') {
                alert("Ch·ª©c nƒÉng s·ª≠a b√†i ƒë·ªçc ch∆∞a ƒë∆∞·ª£c h·ªó tr·ª£ trong phi√™n b·∫£n n√†y.");
                return;
            }

            const updatedData = {
                question: document.getElementById("editQ").innerHTML,
                choices: [
                    document.getElementById("editC1").value,
                    document.getElementById("editC2").value,
                    document.getElementById("editC3").value,
                    document.getElementById("editC4").value,
                ],
                correct: parseInt(document.getElementById("editCorrect").value) - 1,
                explanation: document.getElementById("editExplanation").value.trim(), // L∆∞u gi·∫£i th√≠ch m·ªõi
                // C·∫≠p nh·∫≠t l·∫°i timestamp
                timestamp: serverTimestamp()
            };

            try {
                // C·∫≠p nh·∫≠t document b·∫±ng ID ƒë√£ l∆∞u (q.id)
                await questionsCollection.doc(q.id).update(updatedData);
                closeModal();
                await loadQuestions(); // T·∫£i l·∫°i ƒë·ªÉ c·∫≠p nh·∫≠t hi·ªÉn th·ªã
            } catch (error) {
                console.error("L·ªói khi l∆∞u ch·ªânh s·ª≠a:", error);
                alert("L·ªói khi l∆∞u ch·ªânh s·ª≠a. Ki·ªÉm tra console.");
            }
        }

        // X√≥a (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Firestore)
        async function del(i) {
            if (confirm("X√≥a c√¢u h·ªèi n√†y?")) {
                try {
                    const questionId = questions[i].id;
                    await questionsCollection.doc(questionId).delete();
                    await loadQuestions(); // T·∫£i l·∫°i danh s√°ch
                } catch (error) {
                    console.error("L·ªói khi x√≥a c√¢u h·ªèi:", error);
                    alert("L·ªói khi x√≥a c√¢u h·ªèi. Ki·ªÉm tra console.");
                }
            }
        }

        function closeModal() {
            document.getElementById("editModal").style.display = "none";
        }

        function closePassageModal() {
            document.getElementById("passageEditModal").style.display = "none";
        }

        function closePassagePreviewModal() {
            document.getElementById('passagePreviewModal').style.display = 'none';
            tempPassageData = null;
        }

        // Xu·∫•t JSON (D√πng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫£i)
        function exportJSON() {
            // Lo·∫°i b·ªè tr∆∞·ªùng ID Firebase kh·ªèi d·ªØ li·ªáu xu·∫•t
            const exportData = questions.map(({ id, ...rest }) => rest);
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: "application/json",
            });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = "questions.json";
            a.click();
        }

        // X√≥a to√†n b·ªô (ƒê√£ s·ª≠a ƒë·ªÉ d√πng Batch Delete)
        async function clearAll() {
            if (confirm("X√≥a to√†n b·ªô c√¢u h·ªèi? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c!")) {
                try {
                    // T·∫£i l·∫°i t·∫•t c·∫£ ID l·∫ßn n·ªØa ƒë·ªÉ ƒë·∫£m b·∫£o
                    const snapshot = await questionsCollection.get();
                    if (snapshot.docs.length === 0) return;

                    // D√πng Write Batch ƒë·ªÉ x√≥a nhi·ªÅu document
                    const batch = db.batch();
                    snapshot.docs.forEach((doc) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();

                    questions = [];
                    render();
                    alert("‚úÖ ƒê√£ x√≥a to√†n b·ªô c√¢u h·ªèi th√†nh c√¥ng.");
                } catch (error) {
                    console.error("L·ªói khi x√≥a to√†n b·ªô c√¢u h·ªèi:", error);
                    alert("L·ªói khi x√≥a to√†n b·ªô c√¢u h·ªèi. Ki·ªÉm tra console.");
                }
            }
        }

        // üîπ Format trong modal ch·ªânh s·ª≠a
        function formatEdit(cmd) {
            document.execCommand(cmd, false, null);
            document.getElementById("editQ").focus();
        }
        function clearFormatEdit() {
            document.execCommand("removeFormat", false, null);
            document.getElementById("editQ").focus();
        }

        // üîπ Format trong v√πng d√°n nhanh
        function formatMulti(cmd, targetId = 'quick') {
            const targetDiv = document.getElementById(targetId);
            if (!targetDiv) return;
            const highlighted = targetDiv.querySelectorAll(
                ".multi-select-highlight"
            );

            if (highlighted.length > 0) {
                document.execCommand("styleWithCSS", false, false);
                highlighted.forEach((span) => {
                    const range = document.createRange();
                    range.selectNodeContents(span);
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    document.execCommand(cmd, false, null);
                    selection.removeAllRanges();
                });
            } else {
                document.execCommand(cmd, false, null);
            }
            targetDiv.focus();
        }

        function clearFormatMulti(targetId = 'quick') {
            removeHighlights(targetId);
            document.execCommand("removeFormat", false, null);
            document.getElementById(targetId)?.focus();
        }

        // üîπ Ch·∫ø ƒë·ªô ch·ªçn nhi·ªÅu
        function toggleMultiSelectMode(btn, targetId = 'quick') {
            // T·∫Øt ch·∫ø ƒë·ªô c≈© n·∫øu c√≥
            document.querySelectorAll('#toolbarMulti .active, #toolbarPassage .active').forEach(b => b.classList.remove('active'));

            const isActive = btn.classList.contains('active');
            isMultiSelectMode = !isActive;
            btn.classList.toggle("active", isMultiSelectMode);

            if (!isMultiSelectMode) {
                removeHighlights(targetId);
            }
        }

        function handleMouseUp(e) {
            const targetDiv = e.currentTarget; // ƒê√¢y l√† div contenteditable

            // T√¨m thanh c√¥ng c·ª• t∆∞∆°ng ·ª©ng v·ªõi div n√†y
            const toolbar = targetDiv.previousElementSibling;
            if (!toolbar || !toolbar.id.startsWith('toolbar-')) return;

            // T√¨m n√∫t "Ch·ªçn nhi·ªÅu" ƒëang active trong thanh c√¥ng c·ª• ƒë√≥
            const toggleButton = toolbar.querySelector('button.active');
            if (!toggleButton || !toggleButton.classList.contains('active')) return;

            const selection = window.getSelection();
            if (selection.isCollapsed || !selection.rangeCount) return;

            const range = selection.getRangeAt(0);
            if (!targetDiv.contains(range.commonAncestorContainer)) return;

            const span = document.createElement("span");
            span.className = "multi-select-highlight";
            range.surroundContents(span);
            selection.removeAllRanges();
        }

        document.getElementById("quick").addEventListener("mouseup", handleMouseUp);
        document.getElementById("passage-sub-questions").addEventListener("mouseup", handleMouseUp);
        // L∆∞u √Ω: c√°c √¥ s·ª≠a trong modal s·∫Ω ƒë∆∞·ª£c g·∫Øn s·ª± ki·ªán ƒë·ªông trong h√†m editParsedQuestion


        function removeHighlights(targetId = null) {
            const selector = targetId ? `#${targetId} .multi-select-highlight` : '.multi-select-highlight';
            const highlighted = document.querySelectorAll(selector);
            highlighted.forEach((span) => {
                span.replaceWith(...span.childNodes);
            });
            document.getElementById(targetId || 'quick')?.normalize();
        }

        function toggleInputType(type) {
            if (type === 'single') {
                document.getElementById('single-question-form').style.display = 'block';
                document.getElementById('passage-form').style.display = 'none';
            } else if (type === 'passage') {
                document.getElementById('single-question-form').style.display = 'none';
                document.getElementById('passage-form').style.display = 'block';
            }
        }

        // üîπ X·ª≠ l√Ω d√°n (paste) ƒë·ªÉ lo·∫°i b·ªè ƒë·ªãnh d·∫°ng kh√¥ng mong mu·ªën
        function handlePaste(e) {
            e.preventDefault();
            const text = (e.originalEvent || e).clipboardData.getData('text/plain');
            document.execCommand('insertText', false, text);
        }

        // G·∫Øn s·ª± ki·ªán paste cho c√°c √¥ contenteditable
        document.getElementById('quick').addEventListener('paste', handlePaste);
        document.getElementById('passage-text').addEventListener('paste', handlePaste);
        document.getElementById('passage-sub-questions').addEventListener('paste', handlePaste);
        document.getElementById('editQ').addEventListener('paste', handlePaste);
        document.getElementById('passageEditSubQuestions').addEventListener('paste', handlePaste);


        // üîπ X√≥a n·ªôi dung input
        function clearSingleInput() {
            const quickDiv = document.getElementById('quick');
            if (quickDiv.innerHTML.trim() !== '' && confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô n·ªôi dung ƒë√£ nh·∫≠p?')) {
                quickDiv.innerHTML = '';
            }
        }

        function clearPassageInput() {
            const passageDiv = document.getElementById('passage-text');
            const subQuestionsDiv = document.getElementById('passage-sub-questions');
            if ((passageDiv.innerHTML.trim() !== '' || subQuestionsDiv.innerHTML.trim() !== '') && confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô n·ªôi dung b√†i ƒë·ªçc v√† c√¢u h·ªèi ƒë√£ nh·∫≠p?')) {
                passageDiv.innerHTML = '';
                subQuestionsDiv.innerHTML = '';
            }
        }

        // T·∫£i c√¢u h·ªèi khi trang ƒë∆∞·ª£c load
        loadQuestions();
    </script>
</body>

</html>